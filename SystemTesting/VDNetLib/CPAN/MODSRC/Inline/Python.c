/*
 * This file was generated automatically by ExtUtils::ParseXS version 2.18_02 from the
 * contents of Python.xs. Do not edit this file, edit Python.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST! 
 *
 */

#line 1 "Python.xs"
/* -*- C -*- */
/* vim: set expandtab shiftwidth=4 softtabstop=4 cinoptions='\:2=2': */
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

#include "Python.h"
#include "py2pl.h"
#include "util.h"

#ifdef EXPOSE_PERL
#include "perlmodule.h"
#endif

/* To save a little time, I check the calling context and don't convert
 * the arguments if I'm in void context, flatten lists in list context,
 * and return only one element in scalar context.
 *
 * If this turns out to be a bad idea, it's easy enough to turn off.
 */
#define CHECK_CONTEXT

#ifdef CREATE_PYTHON
void do_pyinit() {
#ifdef EXPOSE_PERL
    PyObject *main_dict;
    PyObject *perl_obj;

    PyObject *dummy1 = PyString_FromString(""),
             *dummy2 = PyString_FromString("main");
#endif
    /* sometimes Python needs to know about argc and argv to be happy */
    int _python_argc = 1;
    char *_python_argv[] = {
        "python",
    };

    Py_SetProgramName("python");
    Py_Initialize();
    PySys_SetArgv(_python_argc, _python_argv);  /* Tk needs this */

#ifdef EXPOSE_PERL
    /* create the perl module and add functions */
    initperl();

    /* now -- create the main 'perl' object and add it to the dictionary. */
    perl_obj = newPerlPkg_object(dummy1,dummy2);
    main_dict = PyModule_GetDict(PyImport_AddModule("__main__"));
    PyDict_SetItemString(main_dict, "perl", perl_obj);

    Py_DECREF(perl_obj);
    Py_DECREF(dummy1);
    Py_DECREF(dummy2);
#endif
}
#endif

#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#line 72 "Python.c"

XS(XS_Inline__Python_py_study_package); /* prototype to pass -Wmissing-prototypes */
XS(XS_Inline__Python_py_study_package)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 0 || items > 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Inline::Python::py_study_package", "PYPKG=\"__main__\"");
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	char*	PYPKG;
#line 73 "Python.xs"
    PyObject *mod;
    PyObject *dict;
    PyObject *keys;
    int len;
    int i;
    AV* const functions = newAV();
    HV* const classes = newHV();
#line 97 "Python.c"

	if (items < 1)
	    PYPKG = "__main__";
	else {
	    PYPKG = (char *)SvPV_nolen(ST(0));
	}
#line 81 "Python.xs"
    mod = PyImport_AddModule(PYPKG);
    dict = PyModule_GetDict(mod);
    keys = PyMapping_Keys(dict);
    len = PyObject_Length(dict);

    Printf(("py_study_package: dict length: %i\n", len));
    for (i=0; i<len; i++) {
        PyObject * const key = PySequence_GetItem(keys,i);
        PyObject * const val = PyObject_GetItem(dict,key);
        if (PyCallable_Check(val)) {
#ifdef I_PY_DEBUG
            printf("py_study_package: #%i (%s) callable\n", i, PyString_AsString(key));
            printf("val:\n\t");
            PyObject_Print(val, stdout, Py_PRINT_RAW);
            printf("\n");
            printf("object type check gives: %i\n", PyType_Check(val));
#endif
            if (PyFunction_Check(val)) {
                char * const name = PyString_AsString(key);
                Printf(("Found a function: %s\n", name));
                av_push(functions, newSVpv(name,0));
            }
            /* elw: if we just could get it to go through here! */
            else if (PyType_Check(val) || PyClass_Check(val)) {
                char * const name = PyString_AsString(key);
                PyObject * const cls_dict = PyObject_GetAttrString(val,"__dict__");
                PyObject * const cls_keys = PyMapping_Keys(cls_dict);
                int const dict_len = PyObject_Length(cls_dict);
                int j;

                /* array of method names */
                AV * const methods = newAV();

                Printf(("Found a class: %s\n", name));

                /* populate the array */
                for (j=0; j<dict_len; j++) {
                    PyObject * const cls_key = PySequence_GetItem(cls_keys,j);
                    PyObject * const cls_val = PyObject_GetItem(cls_dict,cls_key);
                    char * const fname = PyString_AsString(cls_key);
                    if (PyFunction_Check(cls_val)) {
                        Printf(("Found a method of %s: %s\n", name, fname));
                        av_push(methods,newSVpv(fname,0));
                    }
                    else {
                        Printf(("not a method %s: %s\n", name, fname));
                    }
                }

                hv_store(classes,name,strlen(name),newRV_noinc((SV*)methods), 0);
            }
        }
    }
    /* return an expanded hash */
    XPUSHs(newSVpv("functions",0));
    XPUSHs(newRV_noinc((SV*)functions));
    XPUSHs(newSVpv("classes", 0));
    XPUSHs(newRV_noinc((SV*)classes));
#line 163 "Python.c"
	PUTBACK;
	return;
    }
}


XS(XS_Inline__Python_py_eval); /* prototype to pass -Wmissing-prototypes */
XS(XS_Inline__Python_py_eval)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1 || items > 2)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Inline::Python::py_eval", "str, type=1");
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	char *	str = (char *)SvPV_nolen(ST(0));
	int	type;
#line 145 "Python.xs"
    PyObject *	main_module;
    PyObject *	globals;
    PyObject *	locals;
    PyObject *	py_result;
    int             context;
    SV*             ret = NULL;
#line 193 "Python.c"

	if (items < 2)
	    type = 1;
	else {
	    type = (int)SvIV(ST(1));
	}
#line 152 "Python.xs"
    Printf(("py_eval: code: %s\n", str));
    /* doc:  if the module wasn't already loaded, you will get an empty
     * module object. */
    main_module = PyImport_AddModule("__main__");
    if(main_module == NULL) {
        croak("Error -- Import_AddModule of __main__ failed");
    }
    Printf(("py_eval: main_module=%p\n", main_module));
    globals = PyModule_GetDict(main_module);
    Printf(("py_eval: globals=%p\n", globals));
    locals = globals;
    context = (type == 0) ? Py_eval_input :
    (type == 1) ? Py_file_input :
    Py_single_input;
    Printf(("py_eval: type=%i\n", type));
    Printf(("py_eval: context=%i\n", context));
    py_result = PyRun_String(str, context, globals, locals);
    if (!py_result) {
        PyErr_Print();
        croak("Error -- py_eval raised an exception");
        XSRETURN_EMPTY;
    }
    ret = Py2Pl(py_result);
    if (! sv_isobject(ret))
        sv_2mortal(ret); /* if ret is an object, this already gets done by the following line */
    Py_DECREF(py_result);
    if (type == 0)
        XPUSHs(ret);
    else
        XSRETURN_EMPTY;
#line 231 "Python.c"
	PUTBACK;
	return;
    }
}

#undef  NUM_FIXED_ARGS
#define NUM_FIXED_ARGS 2

XS(XS_Inline__Python_py_call_function); /* prototype to pass -Wmissing-prototypes */
XS(XS_Inline__Python_py_call_function)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Inline::Python::py_call_function", "PYPKG, FNAME, ...");
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	char*	PYPKG = (char *)SvPV_nolen(ST(0));
	char*	FNAME = (char *)SvPV_nolen(ST(1));
#line 191 "Python.xs"
    int i;

    PyObject * const mod       = PyImport_AddModule(PYPKG);
    PyObject * const dict      = PyModule_GetDict(mod);
    PyObject * const func      = PyMapping_GetItemString(dict,FNAME);
    PyObject *o         = NULL;
    PyObject *py_retval = NULL;
    PyObject *tuple     = NULL;

    SV* ret = NULL;

#line 268 "Python.c"
#line 204 "Python.xs"
    Printf(("py_call_function\n"));
    Printf(("package: %s\n", PYPKG));
    Printf(("function: %s\n", FNAME));

    if (!PyCallable_Check(func)) {
        croak("'%s' is not a callable object", FNAME);
        XSRETURN_EMPTY;
    }

    Printf(("function '%s' is callable!\n", FNAME));

    tuple = PyTuple_New(items-NUM_FIXED_ARGS);

    for (i=NUM_FIXED_ARGS; i<items; i++) {
        o = Pl2Py(ST(i));
        if (o) {
            PyTuple_SetItem(tuple, i-NUM_FIXED_ARGS, o);
        }
    }

    PUTBACK;

    Printf(("calling func\n"));
    py_retval = PyObject_CallObject(func, tuple);

    SPAGAIN; /* refresh local stack pointer, could have been modified by Perl code called from Python */

    Py_DECREF(func);
    Py_DECREF(tuple);
    Printf(("received a response\n"));
    if (!py_retval || (PyErr_Occurred() != NULL)) {
        croak_python_exception();
        XSRETURN_EMPTY;
    }
    Printf(("no error\n"));
#ifdef CHECK_CONTEXT
    Printf(("GIMME_V=%i\n", GIMME_V));
    Printf(("GIMME=%i\n", GIMME));
    Printf(("G_VOID=%i\n", G_VOID));
    Printf(("G_ARRAY=%i\n", G_ARRAY));
    Printf(("G_SCALAR=%i\n", G_SCALAR));

    /* We can save a little time by checking our context */
    /* For whatever reason, GIMME_V always returns G_VOID when we get forwarded
     * from eval_python().
     */
    if (GIMME_V == G_VOID) {
        Py_DECREF(py_retval);
        XSRETURN_EMPTY;
    }
#endif

    Printf(("calling Py2Pl\n"));
    ret = Py2Pl(py_retval);
    if (! sv_isobject(ret))
        sv_2mortal(ret); /* if ret is an object, this already gets done by the following line */
    Py_DECREF(py_retval);

    if (
#ifdef CHECK_CONTEXT
            (GIMME_V == G_ARRAY) &&
#endif
            SvROK(ret) && (SvTYPE(SvRV(ret)) == SVt_PVAV)) {
        AV* const av = (AV*)SvRV(ret);
        int const len = av_len(av) + 1;
        int i;
        EXTEND(SP, len);
        for (i=0; i<len; i++) {
            PUSHs(sv_2mortal(av_shift(av)));
        }
    }
    else {
        XPUSHs(ret);
    }
#line 344 "Python.c"
	PUTBACK;
	return;
    }
}

#undef  NUM_FIXED_ARGS
#define NUM_FIXED_ARGS 1

XS(XS_Inline__Python_py_call_function_ref); /* prototype to pass -Wmissing-prototypes */
XS(XS_Inline__Python_py_call_function_ref)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Inline::Python::py_call_function_ref", "FUNC, ...");
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	FUNC = ST(0);
#line 286 "Python.xs"
    int i;

    PyObject * const func = (PyObject *) SvIV(FUNC);
    PyObject *o         = NULL;
    PyObject *py_retval = NULL;
    PyObject *tuple     = NULL;

    SV* ret = NULL;

#line 378 "Python.c"
#line 297 "Python.xs"
    Printf(("py_call_function_ref\n"));

    if (!PyCallable_Check(func)) {
        croak("'%p' is not a callable object", func);
        XSRETURN_EMPTY;
    }

    Printf(("function '%p' is callable!\n", func));

    tuple = PyTuple_New(items-NUM_FIXED_ARGS);

    for (i=NUM_FIXED_ARGS; i<items; i++) {
        o = Pl2Py(ST(i));
        if (o) {
            PyTuple_SetItem(tuple, i-NUM_FIXED_ARGS, o);
        }
    }

    PUTBACK;

    Printf(("calling func\n"));
    py_retval = PyObject_CallObject(func, tuple);

    SPAGAIN; /* refresh local stack pointer, could have been modified by Perl code called from Python */

    Py_DECREF(tuple);
    Printf(("received a response\n"));
    if (!py_retval || (PyErr_Occurred() != NULL)) {
        croak_python_exception();
        XSRETURN_EMPTY;
    }
    Printf(("no error\n"));
#ifdef CHECK_CONTEXT
    Printf(("GIMME_V=%i\n", GIMME_V));
    Printf(("GIMME=%i\n", GIMME));
    Printf(("G_VOID=%i\n", G_VOID));
    Printf(("G_ARRAY=%i\n", G_ARRAY));
    Printf(("G_SCALAR=%i\n", G_SCALAR));

    /* We can save a little time by checking our context */
    /* For whatever reason, GIMME_V always returns G_VOID when we get forwarded
     * from eval_python().
     */
    if (GIMME_V == G_VOID) {
        Py_DECREF(py_retval);
        XSRETURN_EMPTY;
    }
#endif

    Printf(("calling Py2Pl\n"));
    ret = Py2Pl(py_retval);
    if (! sv_isobject(ret))
        sv_2mortal(ret); /* if ret is an object, this already gets done by the following line */
    Py_DECREF(py_retval);

    if (
#ifdef CHECK_CONTEXT
            (GIMME_V == G_ARRAY) &&
#endif
            SvROK(ret) && (SvTYPE(SvRV(ret)) == SVt_PVAV)) {
        AV* const av = (AV*)SvRV(ret);
        int const len = av_len(av) + 1;
        int i;
        EXTEND(SP, len);
        for (i=0; i<len; i++) {
            PUSHs(sv_2mortal(av_shift(av)));
        }
    }
    else {
        PUSHs(ret);
    }
#line 451 "Python.c"
	PUTBACK;
	return;
    }
}

#undef  NUM_FIXED_ARGS
#define NUM_FIXED_ARGS 2

XS(XS_Inline__Python_py_call_method); /* prototype to pass -Wmissing-prototypes */
XS(XS_Inline__Python_py_call_method)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Inline::Python::py_call_method", "_inst, mname, ...");
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV*	_inst = ST(0);
	char*	mname = (char *)SvPV_nolen(ST(1));
#line 379 "Python.xs"
    PyObject *inst;

    /* Other variables */
    PyObject *method;    /* the method object */
    PyObject *tuple;     /* the parameters */
    PyObject *py_retval; /* the return value */
    int i;
    SV *ret;

#line 486 "Python.c"
#line 390 "Python.xs"
    Printf(("eval_python_method\n"));

    if (SvROK(_inst) && SvTYPE(SvRV(_inst))==SVt_PVMG) {
        inst = (PyObject*)SvIV(SvRV(_inst));
    }
    else {
        croak("Object did not have Inline::Python::Object magic");
        XSRETURN_EMPTY;
    }

    Printf(("inst {%p} successfully passed the PVMG test\n", inst));

    if (!(PyInstance_Check(inst) || inst->ob_type->tp_flags & Py_TPFLAGS_HEAPTYPE)) {
        croak("Attempted to call method '%s' on a non-instance", mname);
        XSRETURN_EMPTY;
    }

    Printf(("inst is indeed a Python Instance\n"));

    if (!PyObject_HasAttrString(inst, mname)) {
        croak("Python object has no method named %s", mname);
        XSRETURN_EMPTY;
    }

    Printf(("inst has an attribute named '%s'\n", mname));

    method = PyObject_GetAttrString(inst,mname);

    if (!PyCallable_Check(method)) {
        croak("Attempted to call non-method '%s'", mname);
        XSRETURN_EMPTY;
    }

    tuple = PyTuple_New(items-NUM_FIXED_ARGS);
    for (i=NUM_FIXED_ARGS; i<items; i++) {
        PyObject *o = Pl2Py(ST(i));
        if (o) {
            PyTuple_SetItem(tuple, i-NUM_FIXED_ARGS, o);
        }
    }

    PUTBACK;

    Printf(("calling func\n"));
    py_retval = PyObject_CallObject(method, tuple);

    SPAGAIN; /* refresh local stack pointer, could have been modified by Perl code called from Python */

    Py_DECREF(method);
    Py_DECREF(tuple);
    Printf(("received a response %s \n", py_retval));
    if (!py_retval || (PyErr_Occurred() != NULL)) {
        croak_python_exception();
        XSRETURN_EMPTY;
    }

    Printf(("no error\n"));
#ifdef CHECK_CONTEXT
    /* We can save a little time by checking our context */
    if (GIMME_V == G_VOID) {
        Py_DECREF(py_retval);
        XSRETURN_EMPTY;
    }
#endif

    Printf(("calling Py2Pl()\n"));
    ret = Py2Pl(py_retval);
    if (! sv_isobject(ret))
        sv_2mortal(ret); /* if ret is an object, this already gets done by the following line */
    Py_DECREF(py_retval);

    if (
#ifdef CHECK_CONTEXT
            GIMME_V == G_ARRAY &&
#endif
            SvROK(ret) && (SvTYPE(SvRV(ret)) == SVt_PVAV)) {
        /* if it is an array, return the array elements ourselves. */
        AV* const av = (AV*)SvRV(ret);
        int const len = av_len(av) + 1;
        int i;
        EXTEND(SP, len);
        for (i=0; i<len; i++) {
            PUSHs(sv_2mortal(av_shift(av)));
        }
    }
    else {
        PUSHs(ret);
    }
#line 576 "Python.c"
	PUTBACK;
	return;
    }
}

#undef  NUM_FIXED_ARGS
#define NUM_FIXED_ARGS 2

XS(XS_Inline__Python_py_has_attr); /* prototype to pass -Wmissing-prototypes */
XS(XS_Inline__Python_py_has_attr)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Inline::Python::py_has_attr", "_inst, key");
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV*	_inst = ST(0);
	SV*	key = ST(1);
#line 488 "Python.xs"
    PyObject *inst;
    char     *key_name;
    STRLEN   len;

#line 606 "Python.c"
#line 494 "Python.xs"
    Printf(("get_object_data\n"));

    if (SvROK(_inst) && SvTYPE(SvRV(_inst))==SVt_PVMG) {
        inst = (PyObject*)SvIV(SvRV(_inst));
    }
    else {
        croak("Object did not have Inline::Python::Object magic");
        XSRETURN_EMPTY;
    }

    Printf(("inst {%p} successfully passed the PVMG test\n", inst));

    key_name = SvPV(key, len);
    XPUSHs(newSViv(PyObject_HasAttrString(inst, key_name)));
#line 622 "Python.c"
	PUTBACK;
	return;
    }
}

#undef  NUM_FIXED_ARGS
#define NUM_FIXED_ARGS 2

XS(XS_Inline__Python_py_get_attr); /* prototype to pass -Wmissing-prototypes */
XS(XS_Inline__Python_py_get_attr)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Inline::Python::py_get_attr", "_inst, key");
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV*	_inst = ST(0);
	SV*	key = ST(1);
#line 518 "Python.xs"
    PyObject *inst;
    char     *key_name;
    STRLEN   len;
    PyObject *py_retval; /* the return value */
    SV       *ret;

#line 654 "Python.c"
#line 526 "Python.xs"
    Printf(("get_object_data\n"));

    if (SvROK(_inst) && SvTYPE(SvRV(_inst))==SVt_PVMG) {
        inst = (PyObject*)SvIV(SvRV(_inst));
    }
    else {
        croak("Object did not have Inline::Python::Object magic");
        XSRETURN_EMPTY;
    }

    Printf(("inst {%p} successfully passed the PVMG test\n", inst));

    key_name = SvPV(key, len);
    py_retval = PyObject_GetAttrString(inst, key_name);
    if (!py_retval || (PyErr_Occurred() != NULL)) {
        croak_python_exception();
        XSRETURN_EMPTY;
    }

    Printf(("calling Py2Pl()\n"));
    ret = Py2Pl(py_retval);
    if (! sv_isobject(ret))
        sv_2mortal(ret); /* if ret is an object, this already gets done by the following line */
    Py_DECREF(py_retval);

    XPUSHs(ret);
#line 682 "Python.c"
	PUTBACK;
	return;
    }
}

#undef  NUM_FIXED_ARGS
#define NUM_FIXED_ARGS 2

XS(XS_Inline__Python_py_set_attr); /* prototype to pass -Wmissing-prototypes */
XS(XS_Inline__Python_py_set_attr)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Inline::Python::py_set_attr", "_inst, key, value");
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV*	_inst = ST(0);
	SV*	key = ST(1);
	SV*	value = ST(2);
#line 564 "Python.xs"
    PyObject *inst, *py_value;
    char     *key_name;
    STRLEN   len;

#line 713 "Python.c"
#line 570 "Python.xs"
    Printf(("set_attr\n"));

    if (SvROK(_inst) && SvTYPE(SvRV(_inst))==SVt_PVMG) {
        inst = (PyObject*)SvIV(SvRV(_inst));
    }
    else {
        croak("Object did not have Inline::Python::Object magic");
        XSRETURN_EMPTY;
    }

    Printf(("inst {%p} successfully passed the PVMG test\n", inst));

    py_value = Pl2Py(value);
    key_name = SvPV(key, len);
    PyObject_SetAttrString(inst, key_name, py_value);
    Py_DECREF(py_value);

    XSRETURN_EMPTY;
#line 733 "Python.c"
	PUTBACK;
	return;
    }
}

#undef  NUM_FIXED_ARGS
#define NUM_FIXED_ARGS 0

XS(XS_Inline__Python_py_finalize); /* prototype to pass -Wmissing-prototypes */
XS(XS_Inline__Python_py_finalize)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Inline::Python::py_finalize", "");
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 596 "Python.xs"
    Py_Finalize();

    XSRETURN_EMPTY;
#line 760 "Python.c"
	PUTBACK;
	return;
    }
}

#undef  NUM_FIXED_ARGS
#define NUM_FIXED_ARGS 1

XS(XS_Inline__Python_py_is_tuple); /* prototype to pass -Wmissing-prototypes */
XS(XS_Inline__Python_py_is_tuple)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(%s)", "Inline::Python::py_is_tuple", "_inst");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	SV*	_inst = ST(0);
	int	RETVAL;
	dXSTARG;

	RETVAL = py_is_tuple(_inst);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#undef  NUM_FIXED_ARGS
#ifdef __cplusplus
extern "C"
#endif
XS(boot_Inline__Python); /* prototype to pass -Wmissing-prototypes */
XS(boot_Inline__Python)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    char* file = __FILE__;

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
    XS_VERSION_BOOTCHECK ;

        newXS("Inline::Python::py_study_package", XS_Inline__Python_py_study_package, file);
        newXS("Inline::Python::py_eval", XS_Inline__Python_py_eval, file);
        newXS("Inline::Python::py_call_function", XS_Inline__Python_py_call_function, file);
        newXS("Inline::Python::py_call_function_ref", XS_Inline__Python_py_call_function_ref, file);
        newXS("Inline::Python::py_call_method", XS_Inline__Python_py_call_method, file);
        newXS("Inline::Python::py_has_attr", XS_Inline__Python_py_has_attr, file);
        newXS("Inline::Python::py_get_attr", XS_Inline__Python_py_get_attr, file);
        newXS("Inline::Python::py_set_attr", XS_Inline__Python_py_set_attr, file);
        newXS("Inline::Python::py_finalize", XS_Inline__Python_py_finalize, file);
        newXS("Inline::Python::py_is_tuple", XS_Inline__Python_py_is_tuple, file);

    /* Initialisation Section */

#line 61 "Python.xs"
py_true  = perl_get_sv("Inline::Python::Boolean::true",  FALSE);
py_false = perl_get_sv("Inline::Python::Boolean::false", FALSE);
#ifdef CREATE_PYTHON
do_pyinit();
#endif

#line 829 "Python.c"

    /* End of Initialisation Section */

    if (PL_unitcheckav)
         call_list(PL_scopestack_ix, PL_unitcheckav);
    XSRETURN_YES;
}

