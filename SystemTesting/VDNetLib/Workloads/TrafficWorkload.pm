#!/usr/bin/perl
###############################################################################
# Copyright (C) 2011 VMWare, Inc.
# # All Rights Reserved
###############################################################################
package VDNetLib::Workloads::TrafficWorkload;
my $version = "1.0";

#
# It acts as a User Interface for Traffic Workload package.
# Provides data to Session Module in the way which Session Module Understands.
# Uses combinations generated by Iterator, creates object of Session module
# and calls methods of Session class to set up the session before calling
# StartSession.
#

#Traffic workload key/value pairs
#Type (M|S)            => "Traffic",
#Iterations (O|S)      => "1",
#ToolName (O|S|L)      => "netperf",
#NoOfInbound (O|S)     => <1 to ~>,
#NoOfOutbound (O|S)    => <1 to ~>,
#BurstType (O|S)       => "rr,stream,maerts,crr",
#LocalSendSocketSize (O|S|L|R) => <4000-128000>
#LocalReceiveSocketSize (O|S|L|R) => <4000-128000>
#RemoteSendSocketSize (O|S|L|R)   => <4000-128000>
#RemoteReceiveSocketSize (O|S|L|R) => <4000-128000>
#SendMessageSize (O|S|L|R)        => <1000-128000>
#ReceiveMessageSize (O|S|L|R)   => <1000-128000>
#RequestSize (O|S|L|R)          => <1000-128000>
#ResponseSize (O|S|L|R)         => <1000-128000>
#TestDuration (O|S|L|R)         => <1 - ~>
#L3Protocol (O|S|L|R)           => "IPv4",
#L4Protocol (O|S|L|R)           => "TCP,UDP",
#PortNumber (O|S|L|R)           => 45000,
#ClientPort (O|S|L|R)           => 54000,
#PktFragmentation(O|S)          => Enable/Disable,
#PingPktSize (O|S|L|R)          => <1-128>,
#ConnectivityTest (O|S)         => 0/1,
#TCPMSS (O|S|L|R)               => 64000,
#TCPWindowSize(O|S|L|R)         => 1000,
#IperfThreads(O|S|L|R)          => 4,
#MulticastTimeToLive (O|S|L|R)  => 2,
#UDPBandwidth (O|S|L|R)         => 5,
#AlterBufferAlignment (O|S|L|R) => 3000,
#DataIntegrityCheck (O|S)       => Enable/Disable,
#NatedPort (O|S|L|R)            => 45001,
#Verification (O|S|L)           => "pktcap",

use strict;
use warnings;

# For using Swtich Case in Perl
use Switch;
use Data::Dumper;
# Inherit the parent class.
use base qw(VDNetLib::Workloads::ParentWorkload);

use VDNetLib::Common::GlobalConfig qw($vdLogger);
use VDNetLib::Common::VDErrorno qw( FAILURE SUCCESS VDSetLastError VDGetLastError );
use VDNetLib::Common::Iterator;
use VDNetLib::Common::Utilities;
use VDNetLib::Common::GlobalConfig;
use VDNetLib::TestData::TestConstants;

use VDNetLib::Workloads::TrafficWorkload::Session qw(UpdateDefaults);

# The keys in the last two line should not be used as they belong to old code.
# They are just kept to keep the code backward compatible.
my @mgmtKeys = qw(type iterations timeout
                  verification expectedresult portnumber
                  noofinbound noofoutbound  connectivitytest
                  sleepbetweencombos sleepbetweenoperations testadapter supportip
                  supportadapter postmortem parallelsession sleepbetweenworkloads
                  supportadapternetstack testadapternetstack
                  dvportnum testinttype supportinttype verificationresult
                  pktcapfilter onevent onstate verificationadapter whichhelper);

use constant DEFAULT_ITERATIONS => 1;
# This is the default timeout for the entire workload, including all the
# given iterations.
use constant DEFAULT_SESSION_TIMEOUT => 300;
# This is the default default expected result of all the results of all the
# sessions executed.
use constant DEFAULT_EXPECTEDRESULT => "PASS";
# Connectivity test is disabled by default, a user can do a connectivity test
# if he wants to before a test starts by setting the flag
# connectivitytest => "1"
# A connecivity test will be done in case traffic fails.
use constant CONNECTIVITY_TEST => 1;

# Set the default to run TX and RX in parallel or serial
use constant DEFAULT_PARALLEL_SESSION => "no";

# Default for post mortem
use constant DEFAULT_POST_MORTEM => "1";

# Flag to switch from old Verification to new.
use constant NEWVERIFICATION => 1;

################################################################################
#
# new -
#       Creates object of TrafficWorkload. Creates a duplicate hash from
#       existing workloadHash, makes them lowercase. Removes the management
#       keys from the duplicate hash. Updates the SessionDefaults  using this
#       duplicate hash.
#
# Input:
#       ref to Testbed hash (required)
#       ref to TrafficWorkload hash (required)
#
# Results:
#       An instance/object of TrafficWorkload class contatining a
#       Session Summary hash containing all session-ids.
#       "FAILURE", in case of error
#
# Side effects:
#       None
#
###############################################################################

sub new
{
   # Reading input variablesOld
   my $class = shift;
   my %args = @_;
   my $testbed = $args{'testbed'};
   my $trafficHash = $args{'workload'};

   if (not defined $testbed || not defined $trafficHash) {
      $vdLogger->Error("One or more parameters missing in new of Traffic".
                       "Workload. testbed:$testbed trafficHash:$trafficHash ");
      VDSetLastError("ENOTDEF");
      return FAILURE;
   }

   my $self  = {
      testbed => $testbed,
   };

   if (defined $testbed->{logCollector}){
      $self->{localLogsDir} = $testbed->{logCollector}->{logDir} . "/traffic-".
                              VDNetLib::Common::Utilities::GetTimeStamp() .
                              "/";
   } else {
      my $myLogDir = VDNetLib::Common::GlobalConfig::GetLogsDir();
      $myLogDir = $myLogDir . "traffic-";
      $myLogDir = $myLogDir . VDNetLib::Common::Utilities::GetTimeStamp();
      $myLogDir = $myLogDir . "/";
      $self->{localLogsDir} = $myLogDir;
   }
   $vdLogger->Debug("Logs for this traffic workload: $self->{localLogsDir}");

   # Reusing the staf handle from testbed, if not create it.
   $self->{staf}  = $self->{testbed}->{stafHelper};
   if (not defined $self->{staf}) {
      my $options;
      $options->{logObj} = $vdLogger;
      $self->{staf} = VDNetLib::Common::STAFHelper->new($options);
      if (not defined $self->{staf}) {
         $vdLogger->Error("Failed to create VDNetLib::Common::STAFHelper object");
         VDSetLastError("ESTAF");
         return FAILURE;
      }
   }

   # Copy the management keys and then remove them from the hash which
   # will be send to iterator.
   my (%copyTrafficHash, $mgmtKey);
   %copyTrafficHash = (map {lc $_ => $trafficHash->{$_}} keys %$trafficHash);
   foreach $mgmtKey (@mgmtKeys) {
      if (defined $copyTrafficHash{$mgmtKey}) {
         $self->{$mgmtKey} = $copyTrafficHash{$mgmtKey};
         delete  $copyTrafficHash{$mgmtKey};
      }
   }

   # Even if the user does not provide any traffic key run a basic traffic
   # session of tcp. Thus setting tcp.
   if (!keys %copyTrafficHash) {
      $self->{trafficHashRef}->{l4protocol} = "tcp";
   } else {
      # We call UpdateDefaults only if the traffic hash one or more keys
      # defined.
      if (UpdateDefaults(\%copyTrafficHash) eq FAILURE) {
         VDSetLastError(VDGetLastError());
         return FAILURE;
      }
      $self->{trafficHashRef} = \%copyTrafficHash;
   }

   bless $self, $class;
   return $self;
}


###############################################################################
#
# StartWorkload -
#       Starts Workload by creating a session of traffic between a source
#       machine and destination and then get the result of the session.
#       This method calls new on Session module. Elaborate steps are mentioned
#       in the comments.
#
# Input:
#       None
#
# Results:
#       expectedResult - in case it is defined.
#       "FAIL", in case of error
#
# Side effects:
#       None
#
###############################################################################

sub StartWorkload
{
   my $self = shift;
   my ($testIterations, $expResult, $sleepCombo, $parallelExecution);
   my $comboResult;

   if (defined $self->{parallelsession} && $self->{parallelsession} ne "") {
      $parallelExecution = $self->{parallelsession}
   } else {
      $parallelExecution = DEFAULT_PARALLEL_SESSION;
   }
   $vdLogger->Debug("Workload configured for parallel execution: " .
                    "$parallelExecution");
   if ($parallelExecution !~ /yes|no|true|false/i) {
      $vdLogger->Error("Parallel execution must be a string 'no' or 'yes', " .
                       "got: $parallelExecution");
      VDSetLastError("EINVALID");
      return FAILURE;
   }

   # Number of times you want to run all the tests.
   if (defined $self->{iterations} && $self->{iterations} ne "") {
      $testIterations = $self->{iterations}
   } else {
      $testIterations = DEFAULT_ITERATIONS;
   }
   $vdLogger->Debug("Planned test execution iterations: $testIterations");

   if (defined $self->{expectedresult} && $self->{expectedresult} ne "") {
      $expResult = $self->{expectedresult}
   } else {
      $expResult = DEFAULT_EXPECTEDRESULT;
      $self->{expectedresult} = $expResult;
   }
   $vdLogger->Debug("Workload expected result: $expResult");

   if (defined $self->{sleepbetweencombos} &&
       $self->{sleepbetweencombos} =~ m/(\d+)/) {
      $sleepCombo = $1;
   } else {
      $sleepCombo = 0;
   }
   $vdLogger->Debug("Workload sleep amount between combinations: $sleepCombo");

   if (defined $self->{sleepbetweenworkloads} &&
       $self->{sleepbetweenworkloads} =~ m/(\d+)/) {
      $vdLogger->Info("Sleeping $self->{sleepbetweenworkloads} between " .
                      "workloads...");
      sleep($self->{sleepbetweenworkloads});
   }

   my $toolname = $self->{trafficHashRef}->{toolname};
   if ((defined $toolname) && ($toolname =~ m/^scapy$/i)) {
      # If using scapy and user does not specify supportadapter, we
      # assign value of testadapter to supportadapter so to bypass
      # the logic in CreateSupportAdaptersTuple when supportadapter is undef
      if (not defined $self->{supportadapter}) {
         $self->{supportadapter} = $self->{testadapter};
         $vdLogger->Debug("Use $self->{supportadapter} as support adapter " .
                    "for Scapy traffic workload");
      }
   }

   # Code block for getting Node counting & format checking.
   $self->{testadapter} = $self->CreateTestAdapterTuple($self->{testadapter});
   $self->{supportadapter} = $self->CreateSupportAdaptersTuple(
                                      $self->{supportadapter});
   if (defined $self->{trafficHashRef}->{destinationmac}) {
      $self->{trafficHashRef}->{destinationmac} =
         $self->ProcessMAC($self->{trafficHashRef}->{destinationmac});
   }
   my $userNodeCount = 0;
   my $skipCombo = 0;
   my $comboCounter = 0;
   my (%currentCombo, $comboKey, $anotherSession, $ruleCheckResult,
       %currentMachineCombo);

   # 1) Call new of Iterator inside the $testIterations to run the complete
   # test that many number of times.
   while($testIterations--) {
      # Default for traffic is to enable the includeSingleton flag. The reason
      # being, even if there is one conflicting key in all the traffic keys
      # the session will be rejected. Thus its better to use includeSingleton
      $vdLogger->Debug("Counting test iterations down to 0, current " .
                       "iteration: $testIterations");
      my $iteratorObj = VDNetLib::Common::Iterator->new(
                                    workloadHash => $self->{trafficHashRef},
#                                    flag => "includeSingleton"
                                    logdir => $self->{localLogsDir},
                                    );
      if ($iteratorObj eq FAILURE) {
         $vdLogger->Error("Failed to create iterator for test repetition.");
         VDSetLastError(VDGetLastError());
         return "FAIL";
      }
      # 2) Call nexCombination on Iterator Object in a loop. Inside loop make
      # session Object and create session call StartSession to start
      # server and client
      # Run parallel session if inbound and outbound are defined
      # First run inbound and then run outbound sessions.

      $vdLogger->Debug("Iterating through workload combinations...");
      while(%currentCombo = $iteratorObj->NextCombination()) {
         # Var to store the result of this combination.
         my $sessionResult = undef;
         # If this key is defined in traffic hash then workload
         # will sleep for that many sec before working on each
         # combination.
         if (defined $sleepCombo && $sleepCombo != 0) {
            $vdLogger->Info("TrafficWorkload sleeping for "
                            . $sleepCombo ." sec before a Combination ...");
            sleep($sleepCombo);
         }
         $comboCounter++;
         $vdLogger->Info("TrafficWorkload working on Combination " .
                         "$comboCounter:\n" . Dumper(\%currentCombo));
         # Port Number on which Session Server and Client will listen
         if (defined $self->{portnumber}) {
            $vdLogger->Debug("Creating new TrafficWorkload session: " .
                             "port=$self->{portnumber}" .
                             " and logdir=$self->{localLogsDir}");
            $vdLogger->Debug("Creating new TrafficWorkload session: " .
                             " and logdir=$self->{localLogsDir}");
         } else {
            $vdLogger->Debug("Creating new TrafficWorkload session: " .
                             " and logdir=$self->{localLogsDir}");
         }
         my $currentSession = VDNetLib::Workloads::TrafficWorkload::Session->new(
                                              port => $self->{portnumber},
                                              logdir => $self->{localLogsDir},
                                              staf => $self->{staf},
                                                                     );
         if (FAILURE eq $currentSession) {
            $vdLogger->Error("Error creating traffic session.");
            VDSetLastError(VDGetLastError());
            return FAILURE;
         }
         # 3) For each key of Combination check if they conflict each other.
         # E.g. RequestSize(in TCP_RR) and MessagzeSize(TCP_STREAM) are
         # conflicting parameters which cannot belong to same session
         # A combination with these kind of conflicting keys is dropped.
         $vdLogger->Debug("Checking for traffic parameter conflicts.");
         foreach $comboKey (keys %currentCombo) {
            $vdLogger->Trace("Checking traffic session key for conflict: " .
                             "$comboKey");
            $ruleCheckResult = $currentSession->SessionRuleCheck(
                                                    $comboKey,
                                                    $currentCombo{$comboKey}
                                                                );
            if ($ruleCheckResult eq FAILURE) {
               $vdLogger->Error("Failed during key conflict assessment.");
               VDSetLastError(VDGetLastError());
               return FAILURE;
            } elsif ($ruleCheckResult eq 0) {
               $skipCombo = 1;
               $vdLogger->Warn("Skipping combination due to conflict with " .
                               "key: $comboKey");
               $vdLogger->Trace("Traffic parameters with key conflict:\n" .
                                Dumper(\%currentCombo));
               last;
            } else {
               # If RuleCheck passes then keys from the combination are
               # added to the session
               $skipCombo = 0;
               $vdLogger->Trace("RuleCheck success for key: $comboKey");
               $currentSession->{lc($comboKey)} = $currentCombo{$comboKey};
            }
         } # end of for loop

         # If RuleCheck fails then that combination is rejected.
         if ($skipCombo eq 0) {
            # 4) A method of Session class (SetSourceDestionation() ) depends
            # on inbound/outbound key to determine who will be Server(either
            # SUT) and who will be client(helper machine). For that we need to
            # set inbound or outbound in Session object. We do that here
            # based on if both or either of inbound/outbound keys are defined.
            my $inbound = $self->{noofinbound};
            my $outbound = $self->{noofoutbound};
            if ((defined $inbound) && (defined $outbound)) {
               # It is expected that CloneSessionObject would not return 0
               # in this case as inbound/outbound are not present in hash
               # before this point
               $vdLogger->Debug("Traffic session requested inbound and " .
                                "outbound, cloning session.");
               $anotherSession = $currentSession->CloneSessionObject(
                                                               "noofinbound",
                                                               $inbound
                                                                    );
               if ($anotherSession eq FAILURE) {
                  $vdLogger->Error("Cloning traffic session failed.");
                  VDSetLastError(VDGetLastError());
                  return "FAIL";
               }
               # For the cloned session, increment the port on which the session
               # will run as the client from inbound session does not clean
               # up quickly for the server of outbound session to start on that
               # port.
               # A call to method ReadAndWritePort gives the incremented port
               # as every call to this method increments the port.
               # We should not make this call when a user has provided a port
               # Calling this method will change the port for either inbound
               # or outbound connection.
               if (not defined $self->{portnumber}) {
                  my $new_port = $anotherSession->ReadAndWritePort();
                  if ($anotherSession->SetKeyValueInSession("sessionport",
                                                            $new_port) eq
                                                            FAILURE) {
                     $vdLogger->Error("Error setting port of cloned " .
                                      "traffic session: $new_port");
                  } else {
                     $vdLogger->Debug("Set port on cloned traffic session: " .
                                      "$new_port");
                  }
               }
               if ($currentSession->SetKeyValueInSession("noofoutbound",
                                                         $outbound) eq FAILURE) {
                  $vdLogger->Error("Error setting number of outbound " .
                                   "traffic sessions: $outbound");
                  VDSetLastError(VDGetLastError());
                  return "FAIL";
               } else {
                  $vdLogger->Debug("Set number of outbound traffic " .
                                   "sessions: $outbound");
               }
            } elsif (defined $inbound) {
               # Setting inbound key in this traffic session if it is defined
               # by user
               if ($currentSession->SetKeyValueInSession("noofinbound",
                                                         $inbound) eq FAILURE) {
                  $vdLogger->Error("Error setting number of inbound " .
                                   "traffic sessions: $inbound");
                  VDSetLastError(VDGetLastError());
                  return "FAIL";
               } else {
                  $vdLogger->Debug("Set number of inbound traffic " .
                                   "sessions: $inbound");
               }
            } elsif (defined $outbound) {
               # Setting outbound key in this traffic session if it is defined
               # by user
               if ($currentSession->SetKeyValueInSession("noofoutbound",
                                                         $outbound) eq FAILURE) {
                  $vdLogger->Error("Error setting number of outbound " .
                                   "traffic sessions: $outbound");
                  VDSetLastError(VDGetLastError());
                  return "FAIL";
               } else {
                  $vdLogger->Debug("Set number of outbound traffic " .
                                   "sessions: $outbound");
               }
            } else {
                  $vdLogger->Trace("Inbound/Outbound will be set to ".
                               "default as they are not supplied by User");
            }

            my $machineContainer = {};
            my $count = "0";
            my %removeDupEntry1 = map {$_=> 1} @{$self->{testadapter}};
            my %removeDupEntry2;
            my @arrayOfTuple1 = keys %removeDupEntry1;
            my @arrayOfTuple2;
            my $index;
            my $ret;
            %removeDupEntry2 = map {$_=> 1} @{$self->{supportadapter}};
            @arrayOfTuple2 = keys %removeDupEntry2;
            $userNodeCount = scalar(@arrayOfTuple1) + scalar(@arrayOfTuple2);

            foreach my $tuple (@arrayOfTuple1) {  # testadapter nodes
               $vdLogger->Trace("Creating traffic node for test adapter: " .
                                "$tuple");
               $ret = $self->CreateNodes($tuple, $currentSession,
                                         $self->{testadapternetstack});
               if (FAILURE eq $ret) {
                  $vdLogger->Error("Failed to create traffic node for test " .
                                   "adapter: $tuple");
                  VDSetLastError(VDGetLastError());
                  return FAILURE;
               }
               $count = $self->ReturnID($count);
               $index = $count . "-" . $tuple;
               $machineContainer->{$index} = $ret;
               $vdLogger->Trace("Created traffic node at index: $index");
               $count = $count + 1;
           }
           foreach my $tuple (@arrayOfTuple2) {  # supportadapter nodes
              if ($tuple !~ /([0-9]+\.[0-9]+\.[0-9]+\.[0-9]+)/) {
                  $ret = $self->CreateNodes($tuple, $currentSession,
                                            $self->{supportadapternetstack});
                  $vdLogger->Trace("Creating traffic node for support adapter: " .
                                   "$tuple");
               } else {
                  $ret = $self->CreateDummyNodes($tuple,
                                              $machineContainer->{$index});
                  $vdLogger->Trace("Creating traffic node for dummy support" .
                                    "adapter: $tuple");
               }
               if (FAILURE eq $ret) {
                  $vdLogger->Error("Failed to create traffic node for dummy" .
                                   "support adapter: $tuple");
                  VDSetLastError(VDGetLastError());
                  return FAILURE;
               }
               $count = $self->ReturnID($count);
               $index = $count . "-" . $tuple;
               $machineContainer->{$index} = $ret;
               $count = $count + 1;
            }
            my @interfaceTypes = qw(vnic pci vmknic vmnic);
            # XXX(James, Prabuddh): Why not $userNodeCount instead of $count?
            my $noNodes = $count;

            # The no of nodes collected should not be less than the nodes
            # user gave to run traffic on.
            if ($noNodes < $userNodeCount) {
               $vdLogger->Error("Not all nodes user expected were found ".
                                "in testbed. Expected TestAdapter:".
                                "$self->{testadapter} SupportAdater:".
                                "$self->{supportadapter} Found:".
                                Dumper($machineContainer));
               $vdLogger->Trace("Dumping testbed in trafficWorkload:");
               VDSetLastError(VDGetLastError());
               return "FAIL";
            } elsif ($noNodes < 2) {
               # We have to have minimum 2 nodes to test traffic. Loopback is
               # not supported as of now.
               $vdLogger->Info("Less than 2 nodes found in testbed. ".
                                "Expected TestAdapter:".
                                "$self->{testadapter} SupportAdater:".
                                "$self->{supportadapter} Found:".
                                Dumper($machineContainer));
            } else {
               $vdLogger->Debug("User given nodes:$userNodeCount, ".
                                "nodes actually being used:$noNodes".
                                "TestAdapter" . Dumper($self->{testadapter}) .
                                "SupportAdapter" . Dumper($self->{supportadapter}));
            }

            #
            # If the constant OR env var is set to 0 then use
            # old verification.
            #
            my $newVerification = $ENV{NEWVERIFICATION};
            $self->{newverification} = (defined $newVerification) ?
                                         $newVerification : NEWVERIFICATION;
            $vdLogger->Debug("Using traffic 'new verification': " .
                             "$self->{newverification}");

            my $sessionCounter = 1;
            my $sessionContainer = undef;
            my $sessionTemplate = undef;
            %$sessionTemplate = %$currentSession;
            # First iteration will run inbound and second outbound
            # or vice versa. It might only run one in case only one is defined.
            while($sessionCounter--) {
               foreach my $source (sort keys %$machineContainer) {
                  foreach my $dest (sort keys %$machineContainer) {
                     if ($source eq $dest) {
                        # ran a test between same machine would be
                        # redundant.
                        $vdLogger->Trace("Skipping traffic for endpoints " .
                                         "on same machine.");
                        next;
                     }
                     if (exists $sessionContainer->{$dest ."=". $source}) {
                        # We already ran this combination during previous
                        # iterations of for loop.
                        $vdLogger->Trace("Skipping traffic for already run " .
                                         "combination: dest=$dest, " .
                                         "source=$source.");
                        next;
                     }
                     # sut would be 0000-SUT:vnic:1 thus split it
                     if (defined $self->{testadapter}) {
                        # If the user has explicitly said he wants to use
                        # node X as SUT then ignore other nodes
                        my @values = split(/-/, $source);
                        my $value1 = quotemeta($values[1]);
                        if (!grep(/$value1/, @{$self->{testadapter}})) {
                           next;
                        }
                     }
                     if (defined $self->{supportadapter}) {
                        # If the user has explicitly said he wants to use
                        # node X as helper then ignore other nodes
                        my @values = split(/-/, $dest);
                        my $value1 = quotemeta($values[1]);
                        if (!grep(/$value1/, @{$self->{supportadapter}})) {
                           next;
                        }
                     }
                     $currentSession = $self->RunTrafficServer(
                                                 $sessionTemplate,
                                                 $machineContainer->{$source},
                                                 $machineContainer->{$dest});
                     if ($currentSession eq FAILURE) {
                        $vdLogger->Error("Failed running traffic server.");
                        VDSetLastError(VDGetLastError());
                        return "FAIL";
                     } else {
                        $vdLogger->Debug("Traffic server session started.");
                     }
                     # Store it as 0000-SUT:vnic:1=0001-helper2:vmknic:1
                     # which means it ran a test from
                     # SUT:vnic:1 to helper2:vmknic:1
                     my $direction = "";
                     if (defined $sessionTemplate->{noofinbound} &&
                                $sessionTemplate->{noofinbound} ne "") {
                        $direction = $source ."<---". $dest . "inbound";
                     } elsif (defined $sessionTemplate->{noofoutbound} &&
                                $sessionTemplate->{noofoutbound} ne "") {
                        $direction = $source ."--->". $dest . "outbound";
                     } else {
                        $direction = $source ."=". $dest;
                     }
                     $sessionContainer->{$direction} = $currentSession;
                  }
               }
               foreach my $currentSession (keys %$sessionContainer) {
                  if (FAILURE eq $self->RunTrafficClient(
                                    $sessionContainer->{$currentSession})) {
                     $vdLogger->Error("Traffic client failed for " .
                                      $currentSession);
                     VDSetLastError(VDGetLastError());
                     return "FAIL";
                  } else {
                     $vdLogger->Debug("Traffic client started for session: " .
                                      "$currentSession");
                  }
               }
               if ($parallelExecution =~ /no|false/i) {
                  # Run Tx and Rx in sequence.
                  $sessionResult = $self->GetMachinePairResult($sessionContainer,
                                                               $sessionResult);
                  # Making it undef to explicitly call destructor. The reason
                  # we dont call destructor above after GetMachinePairResult
                  # is that multiple clients might be running on same server
                  # thus we dont want to kill server after GetMachinePairResult
                  # from just one client.
                  foreach my $session (keys %$sessionContainer) {
                     delete $sessionContainer->{$session};
                     $currentSession = undef;
                  }
               }
               # A same session might have to be executed as outbound (in case)
               # inbound is already executed. This makes sure the other Session
               # is executed as well.
               if (defined $anotherSession) {
                  $sessionTemplate = $anotherSession;
                  $anotherSession = undef;
                  $sessionCounter++;
               }
            } # end of while loop
            if ($parallelExecution =~ /yes|true/i) {
               # Run Tx and Rx in parallel.
               $sessionResult = $self->GetMachinePairResult($sessionContainer,
                                                            $sessionResult);
               foreach my $session (keys %$sessionContainer) {
                  delete $sessionContainer->{$session};
                  $currentSession = undef;
               }
            }
         } else {  # end of if (skipCombo) loop
            $vdLogger->Warn("Workload combination skipped.");
         }

         #
         # Storing the result of this combination. A combination is applied
         # to all machine pairs and both inbound and outbound. Thus this
         # result is cumulative of all of them
         #
         my $str = Dumper(\%currentCombo);
         $str =~ s/\s+//g;
         if (not defined $sessionResult) {
            $vdLogger->Error("No result from traffic session.");
            VDSetLastError("ENOTDEF");
            return FAILURE;
         } else {
            $comboResult->{$str} = $sessionResult;
            $vdLogger->Info("Expected Result: $expResult, " .
                            "Final Result: $comboResult->{$str} for " .
                            "Combination: $comboCounter");
         }
      } # end of while(nextCombination) loop
   } # end of while loop of iterations

   # If the expected Result for this workload was FAIL
   # and the session reported FAIL for at least one run
   # then we return PASS.
   my $ret = "PASS";
   foreach my $combo (keys %$comboResult) {
      my $thisComboResult =  $comboResult->{$combo};
      if ($thisComboResult =~ /FAIL/i) {
         $ret = "FAIL";
         $vdLogger->Trace("Result for $combo is $thisComboResult");
      }
   }

   #
   # In case of PASS we delete all the logs before returning. This
   # will delete all nested session dirs and verfication
   # logs inside session dirs
   #
   if ((-d $self->{localLogsDir}) && ($ret eq "PASS")) {
      if ($self->{localLogsDir} eq '/') {
         $vdLogger->Error("Attempting to remove something under root system");
         VDSetLastError("EINVALID");
         return "FAIL";
      }
      my $ret = `rm -rf $self->{localLogsDir}`;
      if ($ret ne "") {
         $vdLogger->Error("rm -rf $self->{localLogsDir} failed with $ret");
         $vdLogger->Error("Will eat up storage space.");
      }
   }
   return $ret;
}


###############################################################################
#
# GetMachinePairResult -
#       This function returns final result for one session.
#
# Description:
#       This function checks result of each direction for one session,
#       compute each of them based on algorithm of function inline comment,
#       then save them into $resultBucket, and returns final result for one
#       session from values in $resultBucket.
#
#       When compute final result, it also considers the second parameter
#       $sessionResult, which is result of previous session. Doing so it can
#       remember FAIL result of previous session, and return FAIL if only one
#       session fails.
#
#       Caller for this function is StartWorkload, code flow of it is like:
#         $sessionResult = undef;
#         while(loop all sessions) {
#           $sessionResult = $self->GetMachinePairResult($sessionContainer,
#                                                    $sessionResult);
#         }
#       After this loop, $sessionResult is the final result for all sessions
#       in one combination. Its value is saved into $comboResult.
#
#       After the loops for combinations and iterations, workload final result
#       is calculated from $comboResult, and StartWorkload returns with this
#       final result.
#
# Input:
#       SessionContainer(mandatory) - A hash containing handle of all sessions
#       workloadResult(mandatory)
#
# Results:
#       pass/fail - In case the result of that session is pass/fail or not
#                   expected.
#
# Side effects:
#       None
#
###############################################################################

sub GetMachinePairResult
{
   my $self = shift;
   my $sessionContainer = shift;
   my $sessionResult = shift;
   my $thisSessionResult = "FAIL";
   my ($sessionTimeout, $postMortem);
   my ($currentSession, $resultBucket);

   if (defined $self->{timeout} && $self->{timeout} ne "") {
      $sessionTimeout = $self->{timeout}
   } else {
      $sessionTimeout = DEFAULT_SESSION_TIMEOUT;
   }

   foreach my $currentSessionKey (keys %$sessionContainer) {
      # Code block to fetch result of traffic session
      $currentSession = $sessionContainer->{$currentSessionKey};
      if ($self->{newverification} == 0) {
         $thisSessionResult = $currentSession->GetSessionResult(
                                                  $sessionTimeout,
                                                  $self->{verificationresult});
      } else {
         $thisSessionResult = $currentSession->GetSessionResult($sessionTimeout);
         # Call finish verification for this session
         my $verificationResult = $self->FinishVerification($currentSession);
         if ($verificationResult =~ /FAIL/i) {
            $vdLogger->Debug("Verification result for $currentSession : ".
               "$verificationResult");
            VDSetLastError(VDGetLastError());
            return "FAIL";
         }
      }

      # The assumption for trafficworkload is that verification should always
      # pass. For the negative tests where the traffic workload is expected to
      # fail, Only if the verification passes then traffic session result will
      # be checked and the final result will be decided.
      #  ----------------------------------------------------------------------
      #  VerificationResult |  TrafficResult  | ExpectedResult  | WorkloadFinal
      #  ----------------------------------------------------------------------
      #      FAIL           |     Dont-Care   |  Dont-Care      |   FAIL
      #      PASS           |     PASS        |  PASS           |   PASS
      #      PASS           |     FAIL        |  FAIL           |   PASS
      #      PASS           |     FAIL        |  PASS           |   FAIL
      #      PASS           |     PASS        |  FAIL           |   FAIL
      #  ----------------------------------------------------------------------
      if ($self->{expectedresult} =~ /fail/i) {
         if ($thisSessionResult =~ /fail/i) {
            $thisSessionResult = "PASS";
            $vdLogger->Debug("Traffic is expected to fail and it failed, so ".
            "workload result is pass");
         } else {
            $thisSessionResult = "FAIL";
            $vdLogger->Debug("Traffic is expected to fail but it passed so ".
            "workload result is fail");
         }
      }

      # if the session result was (execution)FAILURE we need to do
      # post mortem
      # Post Mortem does not find out the reason for low throughput.
      # it does try to find why throughput is not defined. May be
      # in future it will :-)
      if ($self->{expectedresult} =~ /(fail|ignore)/i) {
         # If the expectedresult is fail then user must be testing a negative
         # case where there should be no throughput/output/stdout thus we ignore
         # post-mortem for ExpectedResult = fail
         $self->{postmortem} = 0;
      }
      # For negative cases user can switch off the post mortem to save time
      if ($thisSessionResult eq FAILURE && ((not defined $self->{postmortem}) ||
          (defined $self->{postmortem} && $self->{postmortem} !~ /0/i) )) {
         $postMortem = $self->TrafficPostMortem($currentSession);
         if ($postMortem =~ /FAIL/i) {
            $vdLogger->Debug("Post Mortem for $currentSession->{sessionid} ".
                             "failed");
         }
      }
      # If the session errors out we also set return as FAILURE and come out
      # If the session returns PASS but the previous session
      # had set it as FAIL we still report FAIL. Policy is
      # such that even if one session reports FAIL we return FAIL
      # Fix for PR 1200960, sessionid may be the same for different
      # $currentSessionKey, result will be overridden with sessionid.
      $resultBucket->{$currentSessionKey} = $thisSessionResult;
   }

   # We can return FAIL in case the sessionResult is fail and before
   # checking thisSessionResult but it helps to debug thus we check
   # the results of thisSessionResult also.
   foreach my $key (keys %$resultBucket){
      my $value = $resultBucket->{$key};
      if ($value =~ /FAIL/i) {
         $vdLogger->Debug("$resultBucket->{$key} session failed");
         $thisSessionResult = "FAIL";
      } else {
         $vdLogger->Debug("$resultBucket->{$key} session passed");
      }
   }

   if (($thisSessionResult =~ /FAIL/i) ||
       (defined $sessionResult and $sessionResult =~ /FAIL/i)) {
      return "FAIL";
   } else {
      return "PASS";
   }
}


###############################################################################
#
# RunTrafficServer -
#       Take a specification for a session which includes test and support
#       adapter and starts server on support adapter along with
#       initializing verification module, if any.
#
# Input:
#       SessionTemple - A session hash specifying traffic details
#       SUT hash - Machine as center point of testing
#       Helper hash - Machine helping in this testing.
#
# Results:
#       currentSession - A traffic specification containg all details and
#                        also the result of the run.
#       FAILURE - in case of any error.
#
# Side effects:
#       None
#
###############################################################################

sub RunTrafficServer
{
   my $self = shift;
   my $sessionTemplate = shift;
   my $SUT = shift;
   my $helper = shift;

   # Fill default Session Values E.g. If a user does not
   # mention inbound or outbound OR does not mention tcp or udp
   # packets.While filling the default values the SessionRuleCheck
   # Method will check for conflict and return default value in
   # case of no conflict.

   my $currentSession = VDNetLib::Workloads::TrafficWorkload::Session->new(
                                               logdir => $self->{localLogsDir},
                                               staf => $self->{staf},);
   %$currentSession = %$sessionTemplate;

   my $retSSSC = $currentSession->SetSessionServerClient($SUT, $helper);
   if ($retSSSC eq FAILURE) {
      $vdLogger->Error("SetSessionServerClient failed");
      VDSetLastError("EFAILED");
      return FAILURE;
   }

   # Fill default Session Values E.g. If a user does not
   # mention inbound or outbound OR does not mention tcp or udp
   # packets.While filling the default values the SessionRuleCheck
   # Method will check for conflict and return default value in
   # case of no conflict.
   $currentSession->ApplySessionDefaults();

   # This applied for outbound multicast traffic only.
   # In case of multiple VMs and multicast testing we force each
   # multicast server to run on same port and same multicast ip
   # address so that client can connect to multiple servers
   # running on same port and IP but on differnet VMs.
   # 239.1.1.1 = ipv4 Multicast for all systems on the subnet(except routers)
   # ff39::1:1 = ipv6 Multicast for all systems on the subnet(except routers)
   if ($currentSession->{noofoutbound} ne "" &&
      (($currentSession->{routingscheme} =~ m/multicast/i) ||
        $currentSession->{multicasttimetolive} ne "")) {
      if (defined $currentSession->{multicastip}) {
         # If user specifies multicast IP, use that instead of default IPs.
         $vdLogger->Debug("Multicast IP specified explicitily. Not using ".
                          "l3protocol key to get default IPs");
         $currentSession->{server}->{multicastip} =
             $currentSession->{multicastip};
      }
      elsif ((defined $currentSession->{l3protocol}) &&
          ($currentSession->{l3protocol} =~ m/ipv6/i)) {
         $currentSession->{server}->{multicastip} =
                VDNetLib::TestData::TestConstants::MULTICAST_IPV6_ADDR;
      } else {
         $currentSession->{server}->{multicastip} =
                VDNetLib::TestData::TestConstants::MULTICAST_IPV4_ADDR;
      }
      $vdLogger->Debug("Using all systems multicast ip:".
                       $currentSession->{server}->{multicastip});
      $currentSession->{reuseport} = "yes";
   }

   my ($verifyType, $verifyMachine);
   if ($self->{newverification} == 0) {
      if (defined $self->{verification} &&
         $self->{verification} ne ""){
         $verifyType = $self->{verification};
         if (defined $self->{verifymachine}){
            $verifyMachine =  $self->{verifymachine};
         } else {
          $verifyMachine = undef;
         }
      } else {
         $verifyType = "";
      }
   }

   my $curTool = $currentSession->{toolname};
   if ($curTool !~ /spirent/i) {
      # Running a ping test between testips of client and
      # server.
      # We still go on with the test even if ping fails
      # Reason: RunConnectivityTest might return false positives
      if($self->RunConnectivityTest($currentSession) eq FAILURE) {
	 $vdLogger->Debug("Ping Connectivity test returned FAILURE");
      }

      # There are some behavior which are specific to OS, distro
      # or a combination of many entities. E.g. We need to disable
      # Nagle on windows + JF + Small packet combination
      if ($self->ModifySessionBehavior($currentSession) eq FAILURE) {
	 $vdLogger->Debug("ModifySessionBehavior returned FAILURE");
      }
   }

   # 7) This is where the traffic session starts with all the
   # parameters and machines set for traffic flow.
   # A single call starts server as well as number of parallel
   # clients mentioned by user in NoofInbound/NoofOutbound.

   my $noofSessions = $currentSession->{noofinbound} || $currentSession->{noofoutbound};
   $vdLogger->Info("Starting $noofSessions flow(s) from ".
                   "$currentSession->{sessionflow}   ".
                   "flowID:$currentSession->{sessionid}");

   if ($self->{newverification} == 0) {
      $vdLogger->Warn("STILL USING OLD VERIFICATION. Please switch to new");
      if ($currentSession->StartSession($verifyType ,$verifyMachine) eq FAILURE){
         VDSetLastError(VDGetLastError());
         return FAILURE;
      }
   } else {
      my $postMortem;
      if ($currentSession->StartSessionServer() eq FAILURE) {
         VDSetLastError(VDGetLastError());
         $postMortem = $self->TrafficPostMortem($currentSession);
         if ($postMortem =~ /FAIL/i) {
            $vdLogger->Debug("Post Mortem for $currentSession->{sessionid} ".
                             "failed");
         }
         return FAILURE;
      }
      # Start Verification
      if ($self->CallVerification($currentSession) eq FAILURE) {
         VDSetLastError(VDGetLastError());
         return FAILURE;
      }
      # Start one or more clients depending on the values of NoofInbound
      # & NoofInbound.
   }

   return $currentSession;

}


########################################################################
#
# RunTrafficClient --
#     Method to start all clients for the given session (assuming
#     servers are initialized using RunTrafficServer() method)
#
# Input:
#     currentSession: reference to session object
#
# Results:
#     SUCCESS, if clients are executed successfully;
#     FAILURE, in case of any error.
#
# Side effects:
#     None
#
########################################################################

sub RunTrafficClient
{
   my $self = shift;
   my $currentSession = shift;
   if ($currentSession->StartSessionClient() eq FAILURE) {
      VDSetLastError(VDGetLastError());
      my $postMortem = $self->TrafficPostMortem($currentSession);
      if ($postMortem =~ /FAIL/i) {
         $vdLogger->Debug("Post Mortem for $currentSession->{sessionid} ".
                          "failed");
      }
      return FAILURE;
   }
   return SUCCESS;
}
###############################################################################
#
# RunConnectivityTest -
#       Take a session which has everything like client/server testips
#       controlips. Just run a ping test between these two nodes.
#
# Input:
#       currentSession - A session hash specifying traffic details
#       connectivityTestFlag - to perform connecitivity test or not.
#
# Results:
#       SUCCESS - if ping connectivity exits.
#       FAILURE - in case of any error.
#
# Side effects:
#       None
#
###############################################################################

sub RunConnectivityTest
{
   my $self = shift;
   my $currentSession = shift;
   my $connectivityTest = shift;

   if (not defined $connectivityTest) {
      if (defined $self->{connectivitytest}) {
         if ($self->{connectivitytest} eq "1") {
            $vdLogger->Info("User wants to do Ping Connectivity Test ".
                            "before traffic");
         } else {
            $vdLogger->Info("User disabled Ping Connectivity Test");
            return SUCCESS;
         }
      } elsif (CONNECTIVITY_TEST == 0) {
         # Reading the value of ping connectivity test flag.
         # Deafult is 1(enabled)
         $vdLogger->Debug("Ping Connectivity test is disabled by default ");
         return SUCCESS;
      } elsif (CONNECTIVITY_TEST == 1) {
         $vdLogger->Debug("Ping Connectivity test is enabled by default ");
      }
      # Check if we have already tested that connection. Thus we don't
      # test the connection after each combination.
      my $serverip = $currentSession->{server}->{testip};
      my $clientip = $currentSession->{client}->{testip};
      my $connection = $self->{connections}->{$serverip ."->" . $clientip};
      if ((defined $connection) && ($connection == 1)) {
         $vdLogger->Debug("This connection already works. Thus not doing ".
                          "ping connectivity between ".
                          $serverip ."<->" . $clientip);
         return SUCCESS;
      }
   }

   # Skip the ping in case of multicast & broadcast tests.
   if ($currentSession->{routingscheme} =~ m/(broadcast)/i) {
      $vdLogger->Debug("Cannot run Ping Connectivity Test for this ".
                       "type of traffic");
      return SUCCESS;
   }

   # Running a ping test between testips of client and
   # server.
   # The reason for cloning is that currentSesison has the
   # info of client and Server's control and testip thus ping
   # need not find it again.

   my $pingSession = $currentSession->CloneSessionObject("toolname","ping");

   # We calm down the ping hash to just basic stuff by calling this method
   # This method resets the session hash so that we don't do pktstat or vsish
   # verification during basic connectivity test.
   $pingSession->SetTestSession();
   $vdLogger->Info("Ping connectivity test $pingSession->{sessionflow} with 5 packets");
   if ($pingSession->StartSession("",undef) eq FAILURE) {
      $vdLogger->Warn("Not able to ping test interface.".
                      " Still trying test");
      # Calling destructor explicitly
      $pingSession->{server}->{instance0}= undef;
      return FAILURE;
   }
   my $connectivityResult = $pingSession->GetSessionResult(DEFAULT_SESSION_TIMEOUT);
   if ($connectivityResult !~ /PASS|SUCCESS/) {
      $vdLogger->Warn("Ping Connectivity Test failed");
      # Calling destructor explicitly
      $pingSession->{server}->{instance0}= undef;
      return FAILURE;
   } else {
      my $serverip = $pingSession->{server}->{testip};
      my $clientip = $pingSession->{client}->{testip};
      $self->{connections}->{$clientip . "->" . $serverip} = "1";
      $self->{connections}->{$serverip . "->" . $clientip} = "1";
   }
   $pingSession->{server}->{instance0}= undef;
   return SUCCESS;
}


###############################################################################
#
# RunBasicTraffic -
#       Take a session which has everything like client/server testips
#       controlips. Just run a loopback test to make sure binary is ok
#
# Input:
#       currentSession - A session hash specifying traffic details
#       client/server - machine to on loopback test is done.
#
# Results:
#       SUCCESS - if ping connectivity exits.
#       FAILURE - in case of any error.
#
# Side effects:
#       None
#
###############################################################################

sub RunBasicTraffic
{
   my $self = shift;
   my $currentSession = shift;

   # Skip the ping in case of multicast & broadcast tests.
   if ($currentSession->{toolname} =~ m/(ping)/i) {
      $vdLogger->Debug("Not doing basic test for ping as connectivity ".
                       "test already covered that case");
      return SUCCESS;
   }

   # Running a test between testips of client and
   # server with basic testoptions(to segregate if advanced options
   # like sendsocketsize, messagesize etc are causing undefined throughput).
   # The reason for cloning is that currentSesison has the
   # info of client and Server's control and testip thus ping
   # need not find it again.
   # Running this basic test for 5 sec.

   my $basicSession = $currentSession->CloneSessionObject();
   $basicSession->SetTestSession("basic");
   $basicSession->SetKeyValueInSession("toolname", $currentSession->{toolname});
   $vdLogger->Debug("Doing a basic tcp test for 5 sec");
   if ($basicSession->StartSession("",undef) eq FAILURE) {
      # Calling destructor explicitly
      $basicSession->{server}->{instance0}= undef;
      return FAILURE;
   }

   my $basicResult = $basicSession->GetSessionResult(DEFAULT_SESSION_TIMEOUT);
   if ($basicResult !~ /PASS|SUCCESS/) {
      # Calling destructor explicitly
      $basicSession->{server}->{instance0}= undef;
      return "FAIL";
   }
   $basicSession->{server}->{instance0} = undef;
   return "PASS";
}


###############################################################################
#
# ModifySessionBehavior -
#       Take a session which has everything like client/server testips
#       controlips.
#       There are some behavior which are specific to OS, distro
#       or a combination of many entities. E.g. We need to disable
#       Nagle on windows + JF + Small packet combination otherwise it gives
#       less than 1 Mbps throughput PR# 727565
#
# Input:
#       currentSession - A session hash specifying traffic details
#
# Results:
#       SUCCESS - if everything goes well
#       FAILURE - in case of any error.
#
# Side effects:
#       None
#
###############################################################################

sub ModifySessionBehavior
{
   my $self = shift;
   my $currentSession = shift;

   # Nagle is always enabled by default
   # If any one of the participating os is windows
   # and if MTU is 9000 on both sides
   # and if small(message size < 8946) tcp packets are
   # used in a stream mode
   # then disable Nagle for this test.

   # If requestsize and response size are set then it means
   # user is trying to run a Request Response test thus
   # we dont disable Nagle in that case.
   my $sendMessage;
   if (defined $currentSession->{sendmessagesize}) {
      if ($currentSession->{sendmessagesize} eq "") {
         $sendMessage = 0;
      } else {
         $sendMessage = int($currentSession->{sendmessagesize});
         # We don't want to disable Nagle when message size is > 8946
         # Windows MTU = 8986 - 40 TCPIP Header size = 8946
         return SUCCESS if $sendMessage > 8946;
      }
   }

   # Thus if messageSize is 0 or default and all these conditions are met
   # then we disable Nagle.
   if ((int($currentSession->{client}->{mtu}) > 1500) &&
      (int($currentSession->{server}->{mtu}) > 1500) &&
       (($currentSession->{server}->{os} =~ m/win/i) ||
       ($currentSession->{client}->{os} =~ m/win/i)) &&
      ($currentSession->{l4protocol} =~ m/tcp/i) &&
      ($currentSession->{requestsize} eq "") &&
      ($currentSession->{responsesize} eq "") &&
      ($currentSession->{bursttype} =~ m/stream/i))  {
      $currentSession->{disablenagle} = "all";
      $vdLogger->Info("Disabling Nagle(set TCP no delay) for this TCP Stream");
   }
   return SUCCESS;
}



###############################################################################
#
# CleanUpWorkload -
#       A method just to comply with the parent interface.
#
# Input:
#       None
#
# Results:
#       None
#
# Side effects:
#       None
#
###############################################################################

sub CleanUpWorkload
{

   return SUCCESS;

}


###############################################################################
#
# FormatMachineHashUnitTesting -
#       A method which helps in Unit Testing of traffic code. It converts the
#       testbed details into a format which Session & TrafficTool module
#       understands. This will also stop the propagation of change of
#       testbed structure in future to other parts of TrafficWorkload.
#
# Input:
#       A hash containing machine details(required)
#
# Results:
#       a hash format which Session & TrafficTool module understands
#       FAILURE - in case of any error.
#
# Side effects:
#       None
#
###############################################################################

sub FormatMachineHashUnitTesting
{
   caller eq __PACKAGE__ or die "Only TrafficWorkload package can call
                                 this method";
   my ($self, $machine, $node, $routingType) = @_;

   if (not defined $machine) {
      $vdLogger->Error("$machine parameter missing in ".
                       "method FormatMachineHashIPv6");
      VDSetLastError("ENOTDEF");
      return FAILURE;
   }

   my $formattedMachine;
   $formattedMachine->{'testip'} = $machine->{'testip'};
   $formattedMachine->{'esxip'} = $machine->{'host'};
   $formattedMachine->{'macaddress'} = $machine->{'macAddress'};
   if (defined $machine->{'mtu'}) {
      $formattedMachine->{'mtu'} = $machine->{'mtu'};
   } else {
      $formattedMachine->{'mtu'} = 1500;
   }
   if (($routingType =~ m/multicast/i) ||
        defined $self->{trafficHashRef}->{multicasttimetolive}) {
      my $multicastip = VDNetLib::Common::Utilities::GetMulticastIP();
      $vdLogger->Debug("Randomly generated multicast address: $multicastip");
      if ($multicastip =~ m/^2[2-3][4-9]/) {
         if ($multicastip =~ m/\.1$/ || $multicastip =~ m/\.255$/) {
            $vdLogger->Error("$multicastip should ".
                             "not end with 1 or 255 for multicast.");
            VDSetLastError("ENOTDEF");
            return FAILURE;
         }
         $formattedMachine->{'multicastip'} = $multicastip;
      } else {
         $vdLogger->Error("$multicastip should begin ".
                          "with 224 as multicast address");
         VDSetLastError("ENOTDEF");
         return FAILURE;
      }
   }

   if ((defined $self->{verification} && $self->{verification}
        =~ m/(pktcap|stats|dvportstats)/i) && not defined $machine->{'interface'}) {
      my %hash = (controlIP => $formattedMachine->{'controlip'});
      my $hashref = \%hash;
      my @result = VDNetLib::NetAdapter::Vnic::Vnic::GetAllAdapters($hashref);
      if ($result[0] eq "FAILURE") {
         $vdLogger->Error("VDNetLib::NetAdapter::GetAllAdapters failed".
                           VDGetLastError());
         VDSetLastError("EOPFAILED");
         return FAILURE;
      }
      foreach my $objItem (@result) {
         my $testIP = $formattedMachine->{testip};
         if ($objItem ->{ipv4} =~ m/$testIP/) {
            $formattedMachine->{'interface'} = $objItem ->{interface};
         }
      }
      if (not defined $formattedMachine->{'interface'}) {
         $vdLogger->Error("Won't be able to run PacketCapture without".
                          " interface:".Dumper($formattedMachine));
      }
   } elsif (defined $machine->{'interface'}) {
      $formattedMachine->{'interface'} = $machine->{'interface'};
   }

   return $formattedMachine;
}

##############################################################################
#
# ReturnID --
#       A private utility function for appending id as key in a hash
#       depending on the counter value. This helps in keeping the hash
#       formatted, thus sort keys on the hash can be used to read keys
#       in an order.
#
# Input:
#       counter - An integer number.
#
# Results:
#       ID - A string that can be used as keys in an array.
#
# Side effects:
#       None
#
##############################################################################

sub ReturnID
{
   if (caller ne __PACKAGE__) {
      $vdLogger->Error("Private method should only be called by its package");
      VDSetLastError("EINVALID");
      return FAILURE;
   }

   my $self = shift;
   my $counter = shift;
   my $attachID = undef;

   if (0 <= $counter && $counter < 10) {
      $attachID = "000" . $counter;
   }
   if (10 <= $counter && $counter < 100) {
      $attachID = "00" . $counter;
   }
   if (100 <= $counter && $counter < 1000) {
      $attachID = "0" . $counter;
   }


   return $attachID;
}


########################################################################
#
# CallVerification -
#       If Verification key is defined then set event and ask parent
#       to provide the verification hash
#
# Input:
#       Current traffic Session hash (mandatory)
#
# Results:
#       verification Obj - in case verification was called successfully
#       FAILURE - in case of error.
#
# Side effects:
#       None
#
########################################################################

sub CallVerification
{

   my $self = shift;
   my $trafficSession = shift;
   if (not defined $trafficSession) {
      $vdLogger->Error("TrafficSession not defined in CallVerification");
      VDSetLastError("ENOTDEF");
      return FAILURE;
   }

   # Check in cache if we got any verification hash in previous iterations
   # if yes, use it. If no, then see if verification key is defined.
   # if defined get the verification hash. If not defined user does not
   # want to do verification at all thus return SUCCESS and move on with
   # the code flow.
   my $verifyHash = $self->{cache}->{verificationhash};
   if (not defined $verifyHash) {
      if (defined $self->{'verification'}) {
         # Check for supported verification types else assume its a verification
         # hash and ask parent to return that hash.
         # Once all testcase are changes we can remove this part as it is only
         # to keep the code backward compatible.
         if ($self->{'verification'} =~ /(^pktcap$|^stats$|^dvportstats$|^activevmnic$)/i) {
            $verifyHash->{OldTestCase}->{verificationtype} = $self->{'verification'};
            $verifyHash->{OldTestCase}->{verificationtype} = "vsish"
                                 if $self->{'verification'} =~ /stats/i;
            $verifyHash->{OldTestCase}->{verificationtype} = "dvport"
                                 if $self->{'verification'} =~ /dvportstats/i;
            if (defined $self->{'verificationadapter'}) {
               $verifyHash->{OldTestCase}->{target} = $self->{verificationadapter};
            }
            if (defined $self->{'verificationresult'}) {
               #
               # We dont need expectedresult in New Verification.
               # This is just for keeping the code backward compatible
               #
               $verifyHash->{OldTestCase}->{expectedresult} = $self->{verificationresult};
            }
            if (defined $self->{'pktcapfilter'}) {
               $verifyHash->{OldTestCase}->{pktcapfilter} = $self->{pktcapfilter};
            }
            if (defined $self->{'dvportnum'}) {
               $verifyHash->{OldTestCase}->{dvportnum} = $self->{dvportnum};
            }
            $vdLogger->Trace("Generating verification hash to keep code ".
                             "backward compatible".Dumper($verifyHash));
         } elsif (ref($self->{'verification'}) =~ /HASH/i) {
            $verifyHash = $self->{'verification'};
         } else {
            $vdLogger->Trace("Using SetEvent to ReturnWorkloadHash from parent");
            # This is code block for unit testing Verification from Traffic.
            # Else part is the original flow of vdnet.
            if (defined $self->{testbed}->{testbed}->{unitTestVerification}) {
               $verifyHash = $self->{testbed}->{testbed}->{unitTestVerification};
            } else {
               $verifyHash = $self->{testbed}->SetEvent("ReturnWorkloadHash",
                                                        $self->{'verification'});
            }
            if (FAILURE eq $verifyHash || (ref($verifyHash) !~ /HASH/)) {
               $vdLogger->Error("Failed to get Verification hash:" .
                                "$self->{'verification'} from parent");
               VDSetLastError(VDGetLastError());
               return "FAIL";
            }
         }
      }
      # If we have found the verification hash for the first time
      # then save it in cache for subsequent iterations for traffic
      $self->{cache}->{verificationhash} = $verifyHash;
   }

   # If verifcation Hash is still not defined then it means user
   # does not want to do verification
   if (not defined $verifyHash) {
      return SUCCESS;
   }

   $vdLogger->Info("Working on Verification of traffic ".
                   "flowID:$trafficSession->{sessionid}");
   $vdLogger->Trace(Dumper($verifyHash));
   my $veriModule = "VDNetLib::Verification::Verification";
   eval "require $veriModule";
   if ($@) {
      $vdLogger->Error("Loading Verification.pm, failed");
      VDSetLastError("EOPFAILED");
      return FAILURE;
   }

   # A TrafficWorkload has many sessions based on endpoints
   # and combinations. Thus its better to store verification logs
   # in the sessions dir so that its clear which verification
   # was done for which session.
   my $verificationLogs = $self->{localLogsDir} . $trafficSession->{sessionid};
   my $veriObj = $veriModule->new(testbed => $self->{testbed},
                                  verificationhash => $verifyHash,
                                  workloadhash => $trafficSession,
                                  localLogsDir => $verificationLogs);
   if ($veriObj eq FAILURE) {
      $vdLogger->Error("Verification obj creation failed");
      VDSetLastError(VDGetLastError());
      return FAILURE;
   }
   $trafficSession->{verificationHandle} = $veriObj;

   if ($veriObj->StartVerification() eq FAILURE) {
      $vdLogger->Error("StartVerification failed in TrafficWorkload");
      $vdLogger->Debug(Dumper($veriObj));
      VDSetLastError(VDGetLastError());
      return FAILURE;
   }

   return $veriObj;
}


########################################################################
#
# FinishVerification -
#       Calls StopVerification and then GetReesult on verification for
#       the current traffic session
#
# Input:
#       Traffic Session - a traffic sesion which contains the
#       verification handle
#
# Results:
#       SUCCESS - in case session is started successfully
#       FAILURE - in case of error.
#
# Side effects:
#       None
#
########################################################################

sub FinishVerification
{
   my $self = shift;
   my $trafficSession = shift;
   my $verificationResult;

   if (not defined $self->{'verification'}) {
      return SUCCESS;
   } elsif (not defined $trafficSession->{verificationHandle}) {
      $vdLogger->Error("Verfication Handle missing in TrafficWorkload");
      VDSetLastError("ENOTDEF");
      return FAILURE;
   }

   my $veriObj = $trafficSession->{verificationHandle};
   if ($veriObj->StopVerification() eq FAILURE) {
      $vdLogger->Error("StopVerification failed in TrafficWorkload");
      VDSetLastError(VDGetLastError());
      return FAILURE;
   }

   $verificationResult = $veriObj->GetResult();
   #
   # Freeing memory by destroying the obj explicitilty
   #
   $trafficSession->{verificationHandle} = undef;

   if ($verificationResult ne SUCCESS) {
      $vdLogger->Error("Verification of traffic:$trafficSession->{sessionid}".
                       " failed");
      VDSetLastError(VDGetLastError());
      return FAILURE;
   }

   return $verificationResult;
}


########################################################################
#
# TrafficPostMortem -
#       Perfrom post mortem analysis on traffic.
#
# Input:
#       Traffic Session - a traffic sesion which contains the
#       verification handle
#
# Results:
#       SUCCESS - in case session is started successfully
#       FAILURE - in case of error.
#
# Side effects:
#       None
#
########################################################################

sub TrafficPostMortem
{
   my $self = shift;
   my $currentSession = shift;
   my $postMortem;

   # 1) Connectivity Issue
   #    a) Ping connectivity test
   #    b) Perl Socket code test
   # 2) Log Collection
   #    a) ifconfig
   #    b) ethtool -i and ethool -S
   #    c) ps -efa
   #    d) netstat
   # 3) Binary issue. We check this if 1) is SUCCESS
   #    a) binary -h to see if it executes on the machine
   #    b) basic tcp test on both client and server
   # 4) TODO:Low throughput
   $vdLogger->Info("Doing Traffic POST-MORTEM on ".
                   "$currentSession->{sessionid}");
   # 1) First test if the connecitiviy is there.
   #    Running a ping test between testips of client and
   #    server.

   if ($currentSession->{client}{os} =~ /spirent/i) {
      $vdLogger->Warn("Please refer to Spirent debubg logs for more details ");
      return SUCCESS;
   }
   my $toolname = $self->{trafficHashRef}->{toolname};
   if ((defined $toolname) && ($toolname =~ m/^scapy$/i)) {
      $vdLogger->Warn("Please refer to debubg logs for scapy workload fail");
      return SUCCESS;
   }
   my $connectivity = 1;
   $vdLogger->Info("POST-MORTEM: Testing connectivity...");
   if ($self->RunConnectivityTest($currentSession, 1) =~ /FAIL/i) {
      $vdLogger->Error("Traffic PostMortem: No connectivity between ".
                       $currentSession->{'client'}->{testip} .
                       " and " . $currentSession->{'server'}->{testip});
      $connectivity = 0;
   }
   # Perl socket test utility can be called here

   # 3) Binary issue. We check this if 1) is SUCCESS
   #    a) binary -h to see if it executes on the machine
   #    b) loopback test on both client and server to find issues like
   #       if netserver dies after netperf connects to it
   if ($connectivity == 1) {
      $vdLogger->Info("POST-MORTEM: Testing connectivity passed. ".
                      "Testing Binary...");
      $postMortem = $currentSession->SessionPostMortem("BinaryTest");
      if ($postMortem =~ /FAIL/i) {
         $vdLogger->Error("POST-MORTEM: Binary Test failed for ".
                          "traffic between ".
                          $currentSession->{'client'}->{testip} .
                          " and " . $currentSession->{'server'}->{testip});
      } else {
         $vdLogger->Info("POST-MORTEM: Testing Binary passed. ".
                         "Doing basic tcp test...");
         if ($self->RunBasicTraffic($currentSession) =~ /FAIL/i) {
            $vdLogger->Error("POST-MORTEM: basic tcp test ".
                             "failed between ".
                             $currentSession->{'client'}->{testip} .
                             " and " .
                             $currentSession->{'server'}->{testip});
         } else {
            $vdLogger->Info("POST-MORTEM: Basic tcp test passed. ");
         }
      }
   }

   # 2) Log Collection on both machines involved in the session
   #    ifconfig,  b) ethtool -i and ethool -S, c) ps -efa
   #    netstat
   # It should be done irrespective of connecvitiy. As throughput
   # is undefined we need to see what went wrong.
   $vdLogger->Info("POST-MORTEM: Collecting Logs and States...");
   $vdLogger->Info("POST-MORTEM: Logs dir $currentSession->{sessionlogs}");
   $postMortem = $currentSession->SessionPostMortem("logsAndState");
   if ($postMortem eq FAILURE) {
      $vdLogger->Debug("Log collection failed for traffic between ".
                        $currentSession->{'client'}->{testip} .
                       " and " . $currentSession->{'server'}->{testip});
   }

   return SUCCESS;

}

########################################################################
#
# DESTROY -
#       Destructor method for this class
#
# Input:
#       None
#
# Results:
#       None
#
# Side effects:
#       None
#
########################################################################

sub DESTROY
{
   my $self = shift;
   return SUCCESS;

}


###############################################################################
#
# CreateNodes -
#       A method which helps creating a node data structure which gets stored
#       in MachineContainer. It is populated using netadapter object. And it
#       should look like the following:
#          %node = {
#                      'arch' => 'x86_32',
#                      'nodeid' => 'SUT:vnic:1',
#                      'machinename' => 'SUT',
#                      'controlip' => '10.20.119.197',
#                      'os' => 'linux',
#                      'adapterindex' => 1,
#                      'adapter' => 'vnic',
#                      'macaddress' => undef,
#                      'testip' => '192.168.119.197',
#                      'interface' => 'eth0',
#                      'esxip' => '10.20.116.232',
#                      'mtu' => '1500'
#                  };
#
# Input:
#       tuple: A tuple which can look like SUT:vnic:1 for
#              Testbed.pm ver 1.0 (mandatory)
#       currentSession: A hash which has information regarding address
#                       family and routing type. (mandatory)
#       netStack: Name of the netstack to which the adapter is connected to.
#       If the adapter's definition already contained a netStack attribute
#       and user also provided netStack to use, then the user input will take
#       preference over the existing definition.
#       [Applicable only to adapters that are of the type vmknic]
#
# Results:
#       SUCCESS - Reference to %node is returned
#       FAILURE - Return failure in case of any error.
#
# Side effects:
#       None
#
###############################################################################

sub CreateNodes
{
   my $self           = shift;
   my $tuple          = shift;
   my $currentSession = shift;
   my $netStack       = shift;
   my $vmOpsObj       = undef;

   my $newTuple	= $tuple;
   $newTuple	=~ s/\:/\./g;
   my $ref	= $self->{testbed}->GetComponentObject($newTuple);
   if ($ref eq FAILURE) {
      $vdLogger->Error("Failed to resolve tuple $newTuple");
      VDSetLastError(VDGetLastError());
      return FAILURE;
   }
   my $netObj	= $ref->[0];

   my $controlIP = $netObj->{controlIP};
   my $hostObj;
   my $addressFamily = $currentSession->GetFamily();
   my $routingType   = $currentSession->GetRouting();

   if (defined $netObj->{intType} and ($netObj->{intType} =~ /^vmknic/i ||
        $netObj->{intType} =~ /^vmnic/i)) {
      $hostObj = $netObj->{hostObj};
   }
   elsif (defined $netObj->{intType} and $netObj->{intType} =~ /^vnic/i) {
      $vmOpsObj = $netObj->{vmOpsObj};
      $hostObj  = $vmOpsObj->{hostObj};
   }
   my $hostIp = $hostObj->{hostIP};

   if (not defined $addressFamily) {
      $addressFamily = "ipv4";
   }
   if (not defined $routingType) {
      $routingType = "unicast";
   }

   my $cacheID = $tuple . ":" . lc($addressFamily) . ":" . lc($routingType);

   if (exists $self->{cache}->{$cacheID}) {
      $vdLogger->Trace("Using machine cache:".$cacheID ." in FormatMachineHash");
      return $self->{cache}->{$cacheID};
   }

   my $stafObj = $self->{staf};
   my $os      = (defined $vmOpsObj and defined $vmOpsObj->{os}) ? $vmOpsObj->{os} :
		 $stafObj->GetOS($controlIP);
   my $arch    = (defined $vmOpsObj and defined $vmOpsObj->{arch}) ? $vmOpsObj->{arch} :
		 $stafObj->GetOSArch($controlIP);
   if ((not defined $os) || (not defined $arch)) {
      $vdLogger->Error("Either OS type ($os) or Arch ($arch) is not defined");
      VDSetLastError("EOPFAILED");
      return FAILURE;
   }

   my $mtu = ((defined $vmOpsObj) &&
              (defined $vmOpsObj->{vmType}) &&
              ($vmOpsObj->{vmType} =~ /spirent/i)) ?
							1500 :
							$netObj->GetMTU();
   my $mac = ((defined $netObj->{intType} and $netObj->{intType} =~ /^vnic/i) ?
              $netObj->{macAddress} : $netObj->GetMACAddress());

   # Minimum data structure needed for creation of a node
   my %node = (
              'arch'        => $arch,
              'nodeid'      => $tuple,
              'controlip'   => $controlIP,
              'os'          => $os,
              'macaddress'  => $mac,
              'interface'   => $netObj->{'interface'},
              'mtu'         => $mtu,
              );

   if ($addressFamily eq 'ipv4') {
      $node{'testip'} = $self->GetTestIPv4($netObj, $routingType, $os)
   } else {
      $node{'testip'} = $self->GetTestIPv6($netObj, $controlIP, $os);
   }

   if (($routingType =~ m/multicast/i) ||
        defined $self->{trafficHashRef}->{multicasttimetolive}) {
      $node{'multicastip'} = $self->GetMulticastIP($addressFamily);
   }

   if (defined $netObj->{intType} and $netObj->{intType} =~ /vmknic/i) {
      $node{'interface'} = $netObj->{'deviceId'};
      $node{'netstack'} = $netStack || $netObj->{'netstackName'}
   }

   # Validate the node hash
   foreach my $key (keys %node) {
      if (defined $node{$key} and $node{$key} eq FAILURE) {
         $vdLogger->Error("Unable to create node key $key not set correctly");
         VDSetLastError("EOPFAILED");
         return FAILURE;
      }
   }

   $self->{cache}->{$cacheID} = \%node;
   if (not defined $node{interface}) {
      $vdLogger->Error("Interface is not defined in the netadapter object");
      VDSetLastError('ENODEF');
      return FAILURE;
   }
   return \%node;
}


###############################################################################
#
# CreateDummyNodes -
#       A method which helps creating a node data structure which gets stored
#       in MachineContainer.
#       It should look like the following:
#          %node = {
#                      'arch' => 'x86_32',
#                      'nodeid' => 'SUT:vnic:1',
#                      'machinename' => 'SUT',
#                      'controlip' => '10.20.119.197',
#                      'os' => 'linux',
#                      'adapterindex' => 1,
#                      'adapter' => 'vnic',
#                      'macaddress' => undef,
#                      'testip' => '192.168.119.197',
#                      'interface' => 'eth0',
#                      'esxip' => '10.20.116.232',
#                      'mtu' => '1500'
#                  };
#
# Input:
#       ip: Random IP to send traffic
#       machineIndex: A node from machineContainer
#
# Results:
#       SUCCESS - Reference to %node is returned
#       FAILURE - Return failure in case of any error.
#
# Side effects:
#       None
#
###############################################################################

sub CreateDummyNodes
{
   my $self           = shift;
   my $ip             = shift;
   my $machineIndex   = shift;

   my %node;

   $node{controlip} = $machineIndex->{controlip};
   $node{arch} = $machineIndex->{arch};
   $node{interface} = $machineIndex->{interface};
   $node{mtu} = $machineIndex->{mtu};
   $node{os} = $machineIndex->{os};
   $node{nodeid} = $ip;
   $node{testip} = $ip;
   $node{macaddress} = $machineIndex->{macaddress};

   return \%node;
}


###############################################################################
#
# GetTestIPv4 -
#       A method which helps in providing test IPv4 address. The address can be
#       either unicast or broadcast depending upon the routing type.
#
# Input:
#       netAdapterObj: network Adapter Object send from the caller (mandatory)
#       routingType  : either unicast or broadcast (mandatory)
#       os	     : Operating system name of target (mandatory)
#
# Results:
#       SUCCESS - Return Test IPv4
#       FAILURE - Return failure in case of any error.
#
# Side effects:
#       None
#
###############################################################################

sub GetTestIPv4
{
   my $self	     = shift;
   my $netAdapterObj = shift;
   my $routingType   = shift;
   my $os	     = shift;

   my $hostObj = $netAdapterObj->{hostObj};

   # Currently this variable is not being handle properly. Setting the value
   # to 0 since this is meant to work only for non hosted environment.
   # Future fix for this issue is required as this fix is wrong:
   # my $hostedflag = $hostObj->{hostType};
   my $hostedflag = 0;
   my $controlIp = $netAdapterObj->{'controlIP'};

   my $stafObj = $self->{staf};
   my $ret;

   if ($hostedflag && ($os =~ /lin/i)) {
      $ret = VDNetLib::Common::Utilities::KillDHClient(
                                                 $netAdapterObj->{'controlIP'},
                                                 $netAdapterObj->{interface},
                                                 $self->{staf});
   }
   my $ipConfigured;
   my $networkAddr;
   my $testip;

   if ($os =~ /spirent/i) {
      $ipConfigured = 0;
   } else {
      $networkAddr = $netAdapterObj->GetNetworkAddr();
      $vdLogger->Debug("Network address is: " . Dumper($networkAddr));
      if ((not defined $networkAddr) || ($networkAddr eq FAILURE)) {
         $vdLogger->Error("Network address is either not defined or it is " .
                          "set to FAILURE = $networkAddr.");
         return FAILURE;
      }
      $testip = $networkAddr->{'ipv4'};

      if (($testip eq "NULL") || ($testip =~ m/^169/) ||
	  ($testip =~ /^0\.0\./) || ($testip =~ /n\/a/i) ||
	  ($testip eq FAILURE)) {
	 $ipConfigured = 0;
      } else {
	 $ipConfigured = 1;
      }
   }

   if (!$ipConfigured) {
      my $ip = VDNetLib::Common::Utilities::GetAvailableTestIP($controlIp,
							       undef,
							       "ipv4", $os);
      $vdLogger->Debug("Available test ip is $ip");
      if ((defined $ip) && ($ip eq FAILURE)) {
         VDSetLastError("EOPFAILED");
         return FAILURE;
      }
      if ($os =~ /spirent/i) {
	 return $ip;
      }

      $ret = $netAdapterObj->SetIPv4($ip,
                        VDNetLib::Common::GlobalConfig::DEFAULT_NETMASK);
      if ($ret eq FAILURE) {
         $vdLogger->Error("Setting ip:$ip in " . "$controlIp failed. " .
                          "SetIPv4 returned:$ret.");
         VDSetLastError("EOPFAILED");
         return FAILURE;
      }
      $networkAddr = $netAdapterObj->GetNetworkAddr();
   }
   # Gather information again
   if ($routingType =~ m/broadcast/i) {
      return $networkAddr->{broadcast};
   }
   if ($hostedflag) {
      # currently the hosted part
      # is broken. Need to fix it.
      return $testip;
   }
   return $networkAddr->{'ipv4'};
}


###############################################################################
#
# GetTestIPv6 -
#       A method which helps in providing test IPv6 address. The address can be
#       either unicast or broadcast depending upon the routing type.
#
# Input:
#       netAdapterObj: network Adapter Object send from the caller (mandatory)
#       controlIp: IP address of the management network (mandatory)
#
# Results:
#       SUCCESS - Return Test IPv4
#       FAILURE - Return failure in case of any error.
#
# Side effects:
#       None
#
###############################################################################

sub GetTestIPv6
{
   my $self = shift;
   my $netAdapterObj = shift;
   my $controlIp = shift;
   my $testIPv6;

   # This is for unicast address.
   my $findFlag = 0;
   my $ipv6Array = $netAdapterObj->GetIPv6Global();
   $vdLogger->Trace("GetIPv6Global returned:".Dumper($ipv6Array));
   foreach my $testip (@$ipv6Array) {
      if ($testip eq "NULL") {
         last;
      } elsif ($testip =~ m/^2001:bd6::c:2957/i || $testip =~ m/^2011/) {
         $testIPv6 = $testip;
         $findFlag = 1;
         last;
      }
   }
   if ($findFlag == 0) {
      my $ip = VDNetLib::Common::Utilities::GetAvailableTestIPv6($controlIp);
      if (defined $ip && $ip eq FAILURE) {
         VDSetLastError("EOPFAILED");
         return FAILURE;
      }
      # 2001:bd6::000c:2957:426c/64 This is the kind of IPv6 address
      # we try to set with a prefix of 64.
      my $ret = $netAdapterObj->SetIPv6("add",$ip,64);
      # Need to do better error handling later. This is just to unblock
      # subbu from testing end to end
      my $anotherIPv6Array = $netAdapterObj->GetIPv6Global();
      $vdLogger->Trace("GetIPv6Global returned:".
                        Dumper($anotherIPv6Array));
      foreach my $testip (@$anotherIPv6Array) {
         if ($testip =~ m/^2001:bd6::c:2957/i || $testip =~ m/^2011/) {
             $testIPv6 = $testip;
            $findFlag = 1;
         }
      }
   }
   # If the IP address is in the format 2001:bd6::000c:2957:426c/80
   # Remove the prefix.
   if ($testIPv6 =~ m/\//i) {
      my @tempIP = split(/\//, $testIPv6);
      $testIPv6 = $tempIP[0];
   }

   if (not defined $testIPv6) {
      $vdLogger->Error("Unable to create testip for IPv6");
      VDSetLastError("EOPFAILED");
      return FAILURE;
   }
   return $testIPv6;
}

###############################################################################
#
# GetMulticastIP -
#       A method which helps in providing multicast address.
#
# Input:
#
# Results:
#       SUCCESS - Return multicast address
#       FAILURE - Return failure in case of any error.
#
# Side effects:
#       None
#
###############################################################################

sub GetMulticastIP
{
   my $self = shift;
   my $addressFamily = shift;
   my $multicastip;

   if ($addressFamily eq 'ipv4') {
      $multicastip = VDNetLib::Common::Utilities::GetMulticastIP();
      $vdLogger->Debug("Randomly generated multicast address: $multicastip");
      # Multicast address can be any thing between 224 to 239 .
      # except reserved 224.0.0.1 to 224.0.0.255.
      if ($multicastip =~ m/^2[2-3][4-9]/) {
         if ($multicastip =~ m/\.1$/ || $multicastip =~ m/\.255$/) {
            $vdLogger->Error("$multicastip should " .
                             "not end with 1 or 255 for multicast.");
            VDSetLastError("ENOTDEF");
            return FAILURE;
          }
      }
   } else {
      $multicastip = VDNetLib::Common::Utilities::GetMulticastIP("ipv6");
      $vdLogger->Debug("Randomly generated multicast address: $multicastip");
      # Multicast address can be any thing between 224 to 239 .
      # except reserved 224.0.0.1 to 224.0.0.255.
      if ($multicastip =~ m/^2[2-3][4-9]/) {
         if ($multicastip =~ m/\.1$/ || $multicastip =~ m/\.255$/) {
            $vdLogger->Error("$multicastip should ".
                             "not end with 1 or 255 for multicast.");
            VDSetLastError("ENOTDEF");
            return FAILURE;
         }
      }
   }

   if (not defined $multicastip) {
      $vdLogger->Error("$multicastip should begin " .
                       "with 224 as multicast address");
      VDSetLastError("ENOTDEF");
      return FAILURE;
   }
   return $multicastip;
}


###############################################################################
#
# CreateTestAdapterTuple -
#       Creates the test adapter tuples based on the adapter input from the
#       workload
#
# Input:
#       adapter: can be an index or a tuple
#
# Results:
#       SUCCESS - Return reference to test adapter array
#       FAILURE - Return failure in case of any error.
#
# Side effects:
#       None
#
###############################################################################

sub CreateTestAdapterTuple
{
   my $self = shift;
   my $adapter = shift || undef;
   my @arrayAdapter;

   if (defined $adapter) {
      if ($self->{testbed}{version} == 1) {
         if (($adapter =~ /(\d+)/) && ($adapter !~ /[a-zA-Z]/)) {
            $adapter = "SUT:$self->{testinttype}:$adapter";
            push (@arrayAdapter, $adapter);
         }
      }
      @arrayAdapter = split (',',$adapter);
      my @newArray = ();
      foreach my $trafficTuple (@arrayAdapter) {
         my $refArray = VDNetLib::Common::Utilities::ProcessTuple($trafficTuple);
         push @newArray, @$refArray;
      }
      return \@newArray;
   } else {
      $adapter = $self->{testbed}->GetAllTestAdapters();
      if (not defined $adapter) {
         $vdLogger->Error("Unable to get adapter");
         VDSetLastError("EOPFAILED");
         return FAILURE;
      }
      return $adapter;
   }
}

###############################################################################
#
# CreateSupportAdapterTuple -
#       Creates support adapter tuples based on the adapter input from the
#       workload
#
# Input:
#       adapter: can be an index or a tuple
#
# Results:
#       SUCCESS - Return reference to test adapter array except management adapter
#       FAILURE - Return failure in case of any error.
#
# Side effects:
#       None
#
###############################################################################

sub CreateSupportAdaptersTuple
{
   my $self = shift;
   my $adapters = shift || undef;
   my @arrayAdapter;

   if (defined $adapters) {
      if ($self->{testbed}{version} == 1) {
         if (($adapters =~ /(\d+)/) && ($adapters !~ /[a-zA-Z]/)) {
            $adapters = "helper1:$self->{supportinttype}:$adapters";
            push (@arrayAdapter, $adapters);
         }
      }
      @arrayAdapter = split (',',$adapters);
      my @newArray = ();
      foreach my $trafficTuple (@arrayAdapter) {
         my $refArray;
         if ($trafficTuple !~ /([0-9]+\.[0-9]+\.[0-9]+\.[0-9]+)/) {
            $refArray = VDNetLib::Common::Utilities::ProcessTuple($trafficTuple);
            push @newArray, @$refArray;
         } else {
            push @newArray, $trafficTuple;
         }
      }
      return \@newArray;
   } else {
      $adapters = $self->{testbed}->GetAllSupportAdapters();
      if (not defined $adapters) {
         $vdLogger->Error("Unable to get adapter");
         VDSetLastError("EOPFAILED");
         return FAILURE;
      }
      $vdLogger->Debug('Get all adapters: ' . Dumper($adapters));
      # remove the management adapters if any because we don't want them to be
      # support adapter
      $adapters = [ grep !/vnic\.\[0\]/, @$adapters ];
      $vdLogger->Warn('Remove management adapters if any: ' . Dumper($adapters));
      return $adapters;
   }
}


########################################################################
#
# CompareWorkloadResult--
#     Method to compare the workload result with expectedresult and
#     decide the final result
#
# Input:
#     expectedResult : User input expected result
#     actualResult   : Actual workload result
#     workload   : workload name
#
# Results:
#     returns result hash of expected,actual,final result and
#     description
#
# Side effects:
#     None
#
########################################################################

sub CompareWorkloadResult
{
   my $self = shift;
   my ($expectedResult,$actualResult,$workload) = @_;
   my $workloadEndMessage;
   my $finalResult;

   if ($actualResult =~ /skip/i) {
      $finalResult = "SKIP";
   } elsif ($expectedResult =~ /ignore/i) {
      $workloadEndMessage = "Final Result:$actualResult of workload $workload " .
         "IGNORED since the expected result is : " .$expectedResult;
      $finalResult = "PASS";
   } elsif ($actualResult eq FAILURE) {
      # Check for FAILURE is important because for cases when ignore
      # is not given, the error should be caught and noticed.
      $workloadEndMessage = "Workload $workload returns FAIL as " .
         "FAILURE occurred";
      $finalResult = "FAIL";
   } else {
      $workloadEndMessage = "Final result:$actualResult of workload $workload ";
      $finalResult = $actualResult;
   }
   $vdLogger->Debug($workloadEndMessage);

   my $result = {
      'expectedResult' => $expectedResult,
      'result' => $actualResult,
      'finalResult' => $finalResult,
      'workloadEndMessage' => $workloadEndMessage,
   };
   return $result;
}
1;
