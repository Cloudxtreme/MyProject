########################################################################
# Copyright (C) 2014 VMWare, Inc.
# # All Rights Reserved
########################################################################

package VDNetLib::Workloads::TrafficWorkload::ScapyTool;
my $version = "1.0";


#
# This tool utilizes scapy to send network packets
#
# ######################################################################
#
# Currently following keys are supported:
# protocol : Indicates protocol type. Support ICMP, ARP (mandatory)
# DestinationAddress: IP address that packets sent to
#     This key is used to send packets to unknown address. It supports address
#     range like: 1.1.1.1-1.1.1.10.
#     (DestinationAddress or supportadapter MUST appear in workload definition)
# DestinationMAC: Destination MAC address that packets use. (optional)
# SourceAddress: Source IP address that packets use. If not specified,
#     IP address of test adapter will be used. If SourceAddress is a range,
#     then sourcemac will be generated by scapy. (optional)
# SourceMAC: Source MAC address that packets use. If not specified,
#     MAC address of test adapter will be used. If SourceAddress is a range,
#     not need specify this key. (optional)
# ipttl: Value from 1 to 255. Default value is 64 (optional)
# testduration: Packets sending duration in seconds, default is 5. (optional)
# interval: Packets sending interval in millisecond. When testduration specified,
#     interval can not be 0. Default value is 1000ms. (optional)
# pktcount: Total packet number. When this key specified, interval can be set to 0
#     and testduration will not take effect. (optional)
# sourceport: Source port for layer4 protocol (optional)
# destport: Destination port for layer4 protocol (optional)
#
# ######################################################################
#
# Usage: Following are examples to send traffic with scapy tool
#     'Traffic1' => {
#          'Type' => 'Traffic',
#          'toolname' => 'scapy',
#          'protocol' => 'icmp',
#          'TestAdapter'      => "vm.[1].vnic.[1]",
#          'connectivitytest' => "0",
#          'DestinationAddress' => "172.16.250.90",
#          'ipttl' => 10,
#          'interval' => 1000,
#     },
# It will send ICMP echo requests from vm.[1].vnic.[1] to 172.16.250.90 in TTL
# as 10, test duration uses default 5 seconds and interval is 1000 ms.
#
#     'Traffic2' => {
#          'Type' => 'Traffic',
#          'toolname' => 'scapy',
#          'protocol' => 'arp',
#          'TestAdapter'      => "vm.[1].vnic.[1]",
#          'connectivitytest' => "0",
#          'DestinationAddress' => "172.16.250.89-172.16.250.90",
#          'interval' => 0,
#          'pktcount' => '4',
#     },
# It will send 4 ARP requests from vm.[1].vnic.[1] to each of IP specified in
# DestinationAddress. Packet interval is 0. In this example, packet sequence is:
# send 1st ARP request to 172.16.250.89
# send 1st ARP request to 172.16.250.90
# send 2nd ARP request to 172.16.250.89
# send 2nd ARP request to 172.16.250.90
# ...
# send 4th ARP request to 172.16.250.89
# send 4th ARP request to 172.16.250.90
#
#     'Traffic3' => {
#          'Type' => 'Traffic',
#          'toolname' => 'scapy',
#          'protocol' => 'icmp',
#          'TestAdapter'      => "vm.[1].vnic.[1]",
#          'connectivitytest' => "0",
#          'supportadapter' => "vm.[2-3].vnic.[1]",
#     },
# It will send ICMP echo requests from vm.[1].vnic.[1] to vm.[2].vnic.[1] and
# vm.[3].vnic.[1] respectively. Test duration is 5 seconds and interval is 1000ms.
#
#     'Traffic4' => {
#          'Type' => 'Traffic',
#          'toolname' => 'scapy',
#          'protocol' => 'tcp',
#          'TestAdapter'      => "vm.[1].vnic.[1]",
#          'connectivitytest' => "0",
#          'DestinationAddress' => "172.16.250.90",
#          'sourceport' => 1234,
#          'destport' => 2345,
#          'interval' => 0,
#          'pktcount' => '4',
#     },
# It will send TCP packets from vm.[1].vnic.[1] to 172.16.250.90 with source port
# and destination port specified. If not specify both ports, scapy will fill them.
# Packet will be sent out if only there is route for destination address.
# If no route, please specify destination mac for it to be sent.
#
#     'Traffic5' => {
#          'Type' => 'Traffic',
#          'toolname' => 'scapy',
#          'protocol' => 'udp',
#          'TestAdapter'      => "vm.[1].vnic.[1]",
#          'connectivitytest' => "0",
#          'DestinationAddress' => "172.16.250.90",
#          'sourceport' => 1234,
#          'destport' => 2345,
#          'interval' => 0,
#          'pktcount' => '4',
#          'ipttl' => 10,
#     },
# It will send 4 UDP packets from vm.[1].vnic.[1] to 172.16.250.90 with source port
# and destination port specified without interval (interval 0).
# If not specify both ports, scapy will fill them. UDP packets have ttl as 10.
# Packet will be sent out if only there is route for destination address.
# If no route, please specify destination mac for it to be sent.
#
#     'Traffic6' => {
#          'Type' => 'Traffic',
#          'toolname' => 'scapy',
#          'protocol' => 'arp',
#          'TestAdapter'      => "vm.[1].vnic.[1]",
#          'connectivitytest' => "0",
#          'DestinationAddress' => "1.1.2.6",
#          'SourceAddress' => "2.1.1.6",
#          'sourcemac' => "00:06:03:03:03:03",
#          'pktcount' => '4',
#          'interval' => 0,
#     },
# It will send 4 ARP packets from vm.[1].vnic.[1] to 1.1.2.6 with specified source IP
# and source mac address. In this example, packet will be sent from interface
# vm.[1].vnic.[1]. If SourceAddress and sourcemac not specified, it will use
# test adapter's.
#
#     'Traffic7' => {
#          'Type' => 'Traffic',
#          'toolname' => 'scapy',
#          'protocol' => 'arp',
#          'TestAdapter'      => "vm.[1].vnic.[1]",
#          'connectivitytest' => "0",
#          'DestinationAddress' => "1.1.2.6",
#          'SourceAddress' => "2.1.1.1-2.1.1.3",
#          'pktcount' => '4',
#          'interval' => 0,
#     },
# This workload is similar with Traffic6. Difference lies that source IP address
# is address range. In this situation, scapy tool will generate source mac address
# from each source IP address.
#
#     'Traffic8' => {
#          'Type' => 'Traffic',
#          'toolname' => 'scapy',
#          'protocol' => 'icmp',
#          'DestinationAddress' => "1.1.2.10",
#          'DestinationMAC' => "00:10:10:10:10:10",
#          'TestAdapter'      => "vm.[1].vnic.[1]",
#          'connectivitytest' => "0",
#     },
# This workload sends 5 ICMP echo requests in interval of 1 second with
# destination IP and MAC specified. Packet will be sent from interface
# vm.[1].vnic.[1]. Source IP and source MAC use test adapter's.
#
#    'Traffic9' => {
#          'Type' => 'Traffic',
#          'toolname' => 'scapy',
#          'protocol' => 'icmp',
#          l3protocol     => "ipv6",
#          TestAdapter      => "vm.[1].vnic.[1]",
#          connectivitytest => "0",
#          DestinationAddress => "2014::12",
#          DestinationMAC => "00:01:01:01:01:02",
#          SourceAddress => "2013::01",
#          SourceMAC => "00:02:01:01:01:02",
#          ipttl=>10,
#          interval=>1000,
#        },
# This workload sends 5 ICMPv6 echo requests in interval of 1 second with
# destination IP and MAC specified. Packet will be sent from interface
# vm.[1].vnic.[1]. If not specified source IP and MAC, it will use that of
# test adapter's.
#
#     'Traffic10' => {
#          'Type' => 'Traffic',
#          'toolname' => 'scapy',
#          'protocol' => 'tcp',
#          'l3protocol' => 'ipv6',
#          TestAdapter      => "vm.[1].vnic.[1]",
#          connectivitytest => "0",
#          DestinationAddress => "2013::11",
#          DestinationMAC => "00:01:01:01:01:11",
#          'pktcount' => '4',
#          interval=>0,
#          sourceport=>10234,
#          destport=>12345
#        },
# This workload sends 4 TCP IPv6 packets to destination address with source and
# destination port specified. If there is route for destination address,
# destination MAC is not needed. Packets will be sent from vm.[1].vnic.[1].
# If not specified source IP and MAC, it will use that of test adapter's.
#
#     'Traffic11' => {
#          'Type' => 'Traffic',
#          'toolname' => 'scapy',
#          'protocol' => 'udp',
#          'l3protocol' => 'ipv6',
#          TestAdapter      => "vm.[1].vnic.[1]",
#          connectivitytest => "0",
#          DestinationAddress => "2013::11",
#          DestinationMAC => "00:01:01:01:01:11",
#          'pktcount' => '4',
#          interval=>0,
#          sourceport=>10234,
#          destport=>12345
#        },
# This workload sends 4 UDP IPv6 packets to destination address with source and
# destination port specified. If there is route for destination address,
# destination MAC is not needed. Packets will be sent from vm.[1].vnic.[1].
# If not specified source IP and MAC, it will use that of test adapter's.
#
# ######################################################################

# Inherit the parent class.
require Exporter;
use vars qw /@ISA/;
@ISA = qw(VDNetLib::Workloads::TrafficWorkload::TrafficTool);


use strict;
use warnings;
use Switch;
use FindBin;
use lib "$FindBin::Bin/../";
use VDNetLib::Common::GlobalConfig qw($vdLogger);
use Data::Dumper;
use VDNetLib::Common::VDErrorno qw(VDSetLastError VDGetLastError FAILURE SUCCESS);

use constant PYTHON_PATH => "/bldmnt/toolchain/lin32/python-2.7.9-openssl1.0.1k/bin/";
use constant PYTHON_PATH_64 => "/bldmnt/toolchain/lin64/python-2.7.9-openssl1.0.1k/bin/";
use constant BINARY_PYTHON => "python";
use constant BIN_PATH => "/automation/pylib/io_tools/";
use constant SCAPY_SCRIPT => "scapy_tool.py";
use constant SCAPY_LAUNCH_TYPE => "sync";
use constant SCAPY_CONFIG_FILE_PREFIX => "/tmp/scapy_tool.conf.";
use constant TRUE  => VDNetLib::Common::GlobalConfig::TRUE;
use constant FALSE => VDNetLib::Common::GlobalConfig::FALSE;

########################################################################
#
# new --
#       Instantiates ScapyTool object
#
# Input:
#       none
#
# Results:
#       returns object of ScapyTool class.
#
# Side effects:
#       none
#
########################################################################

sub new
{
   my $class    = shift;
   my $self  = {
      # 2 values for mode, "server" and "client".
      'mode' => undef,
      'launch_type' => SCAPY_LAUNCH_TYPE,
      'stdout' => undef,
      'stderr' => undef,
   };
   bless($self, $class);
   return $self;
}

########################################################################
#
# SupportedKeys -
#       Maintains a table of what type of traffic values it supports.
#       It can be expanded to contain more rules.
#       This function is useful in server mode, refer to TrafficTool.pm
#
# Input:
#       None
#
# Results:
#       SUCCESS in case of Supported traffic
#
# Side effects:
#       None
#
########################################################################

sub SupportedKeys
{
   return SUCCESS;
}


#########################################################################
#
# BuildToolCommand -
#       This method returns scapy_tool.py command based on the OS
#
# Input:
#       os (required)
#
# Results:
#       SUCCESS - in case everything goes well.
#       FAILURE - in case of error
#
# Side effects:
#       None
#
########################################################################

sub BuildToolCommand
{
   my $self = shift;
   my %args = @_;
   my $os = $args{os};
   my $arch = $args{arch};

   if (not defined $os) {
      $vdLogger->Error("OS type is not defined");
      VDSetLastError("ENOTDEF");
      return FAILURE;
   }
   if (not defined $arch) {
      $vdLogger->Error("Parameter arch is not defined");
      VDSetLastError("ENOTDEF");
      return FAILURE;
   }
   $self->{command} = PYTHON_PATH_64 . BINARY_PYTHON . " " .
                             BIN_PATH . SCAPY_SCRIPT;
   if ($arch eq "x86_32") {
      $self->{command} = PYTHON_PATH . BINARY_PYTHON . " " .
                             BIN_PATH . SCAPY_SCRIPT;
   }
   return SUCCESS;
}


########################################################################
#
# GetToolOptions -
#       This translates the traffic keywords into the language which
#       scapy_tool understands.
#
# Input:
#       Session Key (required)   - E.g. protocol
#       Session ID (required)    - A hash containing session keys and
#                                  session values
#
# Results:
#       string in case of success which indicates tool option and values
#       0 in case there is no translation for that key
#       FAILURE in case of failure
#
# Side effects:
#       None
#
########################################################################

sub GetToolOptions
{
   my $self  = shift;
   my %args  = @_;
   my $sessionKey = $args{'sessionkey'};
   my $sessionID  = $args{'sessionID'};
   my $sessionValue = undef;
   my $ret = 0;

   if (not defined $sessionKey) {
      $vdLogger->Error("Parameter sessionkey not defined");
      VDSetLastError("ENOTDEF");
      return FAILURE;
   }
   if (not defined $sessionID ) {
      $vdLogger->Error("Parameter sessionID not defined");
      VDSetLastError("ENOTDEF");
      return FAILURE;
   }

   $sessionValue = $sessionID->{$sessionKey};
   if ($sessionValue eq "") {
      return 0;
   }

   switch ($sessionKey) {
      case m/DestinationAddress/i {
         $ret = "destination_address=$sessionValue";
         last;
      }
      case m/DestinationMAC/i {
         $ret = "destination_mac=$sessionValue";
         last;
      }
      case m/SourceAddress/i {
         $ret = "source_address=$sessionValue";
         last;
      }
      case m/SourceMAC/i {
         $ret = "source_mac=$sessionValue";
         last;
      }
      case m/^protocol$/i {
         $ret = "protocol=$sessionValue";
         last;
      }
      case m/^testduration$/i {
         $ret = "duration=$sessionValue";
         last;
      }
      case m/^interval$/i {
         $ret = "interval=$sessionValue";
         last;
      }
      case m/^ipttl$/i {
         $ret = "ipttl=$sessionValue";
         last;
      }
      case m/^pktcount$/i {
         $ret = "pktcount=$sessionValue";
         last;
      }
      case m/^sourceport$/i {
         $ret = "sourceport=$sessionValue";
         last;
      }
      case m/^destport$/i {
         $ret = "destport=$sessionValue";
         last;
      }
      case m/^l3protocol$/i {
         $ret = "l3protocol=$sessionValue";
         last;
      }
      case m/^payload$/i {
         $ret = "payload=$sessionValue";
         last;
      }
      case m/^tcpflags$/i {
         $ret = "tcpflags=$sessionValue";
         last;
      }
      case m/^tcpseq$/i {
         $ret = "tcpseq=$sessionValue";
         last;
      }
      case m/^tcpack$/i {
         $ret = "tcpack=$sessionValue";
         last;
      }
   }
   return $ret;
}


########################################################################
#
# GetLaunchType --
#       Overrides the parent method and returns launch type of process.
#
# Input:
#       none
#
# Results:
#       sync as scapy_tool should be executed in sync mode.
#
# Side effects;
#       none
#
########################################################################

sub GetLaunchType
{
   my $self  = shift;
   return $self->{launch_type};
}

###############################################################################
#
# ToolSpecificJob -
#       A method which the child can override and do things which are
#       specific to that tool.
#
# Input:
#       None
#
# Results:
#       SUCCESS - to comply with interface
#
# Side effects:
#       None
#
###############################################################################

sub ToolSpecificJob
{
   return SUCCESS;
}


########################################################################
#
# IsToolServerRunning --
#       Overrides the parent method as there is nothing to be done in
#       scapy. Scapy does not need server running
#
# Input:
#       None
#
# Results:
#       SUCCESS - in case tool server is running
#       FAILURE - in case of error.
#
# Side effects;
#       none
#
########################################################################

sub IsToolServerRunning
{
   return SUCCESS;
}


########################################################################
#
# GetThroughput --
#       Throughput is actually means session output in client mode
#       This function is to add stdout of Scapy session into debug log
#       This function is only valid in client mode.
#
# Input:
#       Session ID (required)    - A hash containing session keys and
#                                  session values
#
# Results:
#       SUCCESS if test succeeded
#       FAILURE in case of error.
#
# Side effects;
#       none
#
########################################################################

sub GetThroughput
{
   my $self = shift;
   my $sessionID = shift;

   if ($self->{mode} =~ /server/i) {
      $vdLogger->Error("Method is valid only for client mode");
      VDSetLastError("EINVALID");
      return FAILURE;
   }
   my $clientInstance = $self->{instance};
   $clientInstance = "Client-" . $clientInstance;

   $vdLogger->Debug("Scapy on $clientInstance returned: " .
                    "$self->{stdout}");
   if (defined $self->{stderr}) {
      $vdLogger->Debug("stderr : $self->{stderr}");
   }
   return SUCCESS;
}

########################################################################
#
# StartServer -
#       This method is required as parent enforces server model
#
# Input:
#       None
#
# Results:
#       SUCCESS - to comply with interface
#       FAILURE - in case of error
#
# Side effects:
#       None
#
########################################################################

sub StartServer
{
   return SUCCESS;

}


########################################################################
#
# CheckOptions --
#       Check test options corrent or not
#
# Input:
#       None
#
# Results:
#       TRUE if options are corrent, else return FALSE
#
# Side effects:
#       None
#
########################################################################

sub CheckOptions
{
   my $self = shift;

   # interval=0 is valid only if pktcount specified.
   if (($self->{testOptions} =~ /interval=0/) &&
       ($self->{testOptions} !~ /pktcount/i)) {
      $vdLogger->Error("Start scapy failed: interval value 0 is valid " .
                       "only if pktcount specified");
      $vdLogger->Debug("Options for scapy : $self->{testOptions}");
      VDSetLastError("EINVALID");
      return FALSE;
   }

   return TRUE;
}

########################################################################
#
# StartClient --
#       Start client of tool on the targetHost to via local testIP
#       Execute self->{command} on the targetHost with testOptions
#
# Input:
#       Object of Session class - Session ID (required)
#
# Results:
#       Stores the result in self->result
#       FAILURE - in case of error
#
# Side effects:
#       None
#
########################################################################

sub StartClient
{
   my $self = shift;
   my $sessionID = shift;
   my ($command, $opts, $result, $srcIP, $srcMAC, $controlIP, $dstIP);
   my ($configFile, $mcIP);
   if (not defined $sessionID) {
      $vdLogger->Error("Parameter sessionID not defined");
      VDSetLastError("ENOTDEF");
      return FAILURE;
   }
   if (not defined $sessionID->{'client'}) {
      $vdLogger->Error("client not defined in parameter sessionID");
      VDSetLastError("ENOTDEF");
      return FAILURE;
   }
   if (ref($sessionID->{'client'}) ne "HASH") {
      $vdLogger->Error("client is not a HASH in parameter sessionID");
      VDSetLastError("EINVALID");
      return FAILURE;
   }
   $controlIP = $sessionID->{'client'}->{'controlip'};
   if (not defined $controlIP) {
      $vdLogger->Error("Control IP not defined in client session");
      VDSetLastError("ENOTDEF");
      return FAILURE;
   }
   $srcIP = $sessionID->{'client'}->{'testip'};
   $srcMAC = $sessionID->{'client'}->{'macaddress'};
   if (not defined $srcIP) {
      $vdLogger->Error("client IP not defined");
      VDSetLastError("ENOTDEF");
      return FAILURE;
   }
   if (not defined $srcMAC) {
      $vdLogger->Error("client MAC address not defined");
      VDSetLastError("ENOTDEF");
      return FAILURE;
   }
   if (not defined $sessionID->{'server'}) {
      $vdLogger->Error("server not defined in parameter sessionID");
      VDSetLastError("ENOTDEF");
      return FAILURE;
   }
   if (ref($sessionID->{'server'}) ne "HASH") {
      $vdLogger->Error("server is not a HASH in parameter sessionID");
      VDSetLastError("EINVALID");
      return FAILURE;
   }

   # We give the liberty to the tool to be invoked in async or sync mode.
   my $launchType = $self->GetLaunchType();
   $launchType = SCAPY_LAUNCH_TYPE if not defined $launchType;

   $vdLogger->Trace("Starting traffic tool client in mode: $launchType");

   if (not defined $self->{command}) {
      $vdLogger->Error("StartClient: command is not defined: ".Dumper($self));
      VDSetLastError("ENOTDEF");
      return FAILURE;
   }

   if ($self->CheckOptions() == FALSE) {
      return FAILURE;
   }

   # Now working on the client part
   my $instance = $self->{instance};
   # For scapy, dst IP is specified by supportadapter if no DestinationAddress
   # specified
   $dstIP = $sessionID->{server}->{testip};
   if ($self->{testOptions} !~ /destination_address/i) {
      if (not defined $dstIP) {
         $vdLogger->Error("testip not defined in server session");
         VDSetLastError("ENOTDEF");
         return FAILURE;
      }
      $self->{testOptions} = $self->{testOptions} . " destination_address=$dstIP";
   }
   # Append source mac and IP, source interface
   if ($self->{testOptions} !~ /source_address/i) {
      $self->{testOptions} .= " source_address=$srcIP";
   }
   if ($self->{testOptions} !~ /source_mac/i) {
      $self->{testOptions} .= " source_mac=$srcMAC";
   }
   $opts = $sessionID->{'client'}->{'interface'};
   if ((defined $opts) && ($opts ne "")) {
      $self->{testOptions} .= " sourceiface=$opts";
   }
   $vdLogger->Debug("Options for scapy : $self->{testOptions}");

   if (($mcIP = VDNetLib::Common::Utilities::GetLocalIP()) eq FAILURE) {
      $vdLogger->Error("Not able to get LocalIP");
      return FAILURE;
   }
   # Save these options into file and copy the file to client host
   $self->{testOptions} =~ s/^\s+|\s+$//g;
   $self->{testOptions} =~ s/\s+/\n/g;
   $configFile = SCAPY_CONFIG_FILE_PREFIX . $$;
   my $fh;
   if (not defined open($fh, "> " . $configFile)) {
      $vdLogger->Error("Unable to open file $configFile");
      return FAILURE;
   }
   print $fh "[SCAPY_CONFIG]\n";
   print $fh "$self->{testOptions}";
   close $fh;
   $result = $self->{staf}->STAFFSCopyFile($configFile, "/tmp/",
              $mcIP, $controlIP);
   if ($result ne 0) {
      $vdLogger->Error("Failed to copy scapy config file to client VM");
      VDSetLastError("ESTAF");
      return FAILURE;
   }

   $command = "$self->{command} -f $configFile";
   if($instance == 1) {
      $vdLogger->Info("Launching traffic client-". $instance .
                   " ($self->{command}) on $controlIP");
      $vdLogger->Info("with testoptions: -f $configFile");
   } else {
      $vdLogger->Info("Launching traffic client-". $instance .
                   " with same testoptions");
      $vdLogger->Trace("testoptions for $instance are: $self->{testOptions}");
   }

   $result = $self->{staf}->STAFSyncProcess($controlIP,
                                            $command);

   if ($result->{rc} || $result->{exitCode}) {
      $vdLogger->Error("Command $command failed: " . Dumper($result));
      VDSetLastError("ESTAF");
      return FAILURE;
   }
   $self->{stdout} = $result->{stdout};
   $self->{stderr} = $result->{stderr};
   if ($self->{stdout} =~ /ERROR:/) {
      $vdLogger->Error("Command $command failed: " . $self->{stdout});
      VDSetLastError("EFAIL");
      return FAILURE;
   }
   return SUCCESS;
}

########################################################################
# Stop --
#       Terminates toolserver process on the targetHost
#       This is to override same function in parent class. Since no real
#       server for Scapy, we directly return SUCCESS
#
# Input:
#       Object of Session class - Session ID (required)
#
# Results:
#       SUCCESS if stop completed
#       FAILURE - in case of error.
#
# Side effects:
#       none
#
########################################################################

sub Stop
{
   my $self = shift;
   my $sessionID = shift;

   # Stop method is only for server. As, if you stop the server the client
   # stops on its own.
   if ($self->{mode} !~ m/server/i) {
      $vdLogger->Error("Stop method only applicable for Server mode while " .
                       "current mode is $self->{mode}");
      VDSetLastError("EINVALID");
      return FAILURE;
   }
   return SUCCESS;
}
